{
    "ConvexHullTrick": {
        "prefix": "ConvexHullTrick",
        "body": [
            "template <typename T>",
            "struct ConvexHullTrick {",
            "\tvoid add(const T& a, const T& b) {",
            "\t\tLinear l(a, b);",
            "\t\tassert((int)ls.size() == 0 or ls.back().a >= l.a);",
            "\t\tint len = (int)ls.size();",
            "\t\twhile(len >= 2 and check(ls[len - 2], ls[len - 1], l)) {",
            "\t\t\t--len;",
            "\t\t\tls.pop_back();",
            "\t\t}",
            "\t\tls.push_back(l);",
            "\t}",
            "\tT operator()(const T& x) {",
            "\t\twhile((int)ls.size() >= 2 and ls[0](x) >= ls[1](x)) {",
            "\t\t\tls.pop_front();",
            "\t\t}",
            "\t\treturn ls[0](x);",
            "\t}",
            "",
            "   private:",
            "\tstruct Linear {",
            "\t\tT a, b;",
            "\t\tLinear(const T& a = 0, const T& b = 0)",
            "\t\t\t: a(a), b(b) {}",
            "\t\tinline T operator()(const T& x) const {",
            "\t\t\treturn a * x + b;",
            "\t\t}",
            "\t};",
            "\tinline bool check(const Linear& f1, const Linear& f2, const Linear& f3) const {",
            "\t\treturn (f2.a - f1.a) * (f3.b - f2.b) >= (f2.b - f1.b) * (f3.a - f2.a);",
            "\t}",
            "\tdeque<Linear> ls;",
            "};",
        ]
    },
    "DisjointSetUnion": {
        "prefix": "DisjointSetUnion",
        "body": [
            "struct DisjointSetUnion {",
            "\tDisjointSetUnion(int N)",
            "\t\t: n(N), data(N, -1) {}",
            "\tint merge(int a, int b) {",
            "\t\tassert(0 <= a and a < n);",
            "\t\tassert(0 <= b and b < n);",
            "\t\tint x = leader(a), y = leader(b);",
            "\t\tif(x == y) return x;",
            "\t\tif(-data[x] < -data[y]) swap(x, y);",
            "\t\tdata[x] += data[y];",
            "\t\tdata[y] = x;",
            "\t\treturn x;",
            "\t}",
            "\tbool same(int a, int b) {",
            "\t\tassert(0 <= a and a < n);",
            "\t\tassert(0 <= b and b < n);",
            "\t\treturn leader(a) == leader(b);",
            "\t}",
            "\tint leader(int a) {",
            "\t\tassert(0 <= a and a < n);",
            "\t\tif(data[a] < 0) return a;",
            "\t\treturn data[a] = leader(data[a]);",
            "\t}",
            "\tint size(int a) {",
            "\t\tassert(0 <= a and a < n);",
            "\t\treturn -data[leader(a)];",
            "\t}",
            "\tvector<vector<int>> groups() {",
            "\t\tvector<int> leader_buf(n), group_size(n);",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tleader_buf[i] = leader(i);",
            "\t\t\t++group_size[leader_buf[i]];",
            "\t\t}",
            "\t\tvector<vector<int>> result(n);",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tresult[i].reserve(group_size[i]);",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tresult[leader_buf[i]].push_back(i);",
            "\t\t}",
            "\t\tresult.erase(remove_if(result.begin(), result.end(), [&](const vector<int>& v) { return v.empty(); }), result.end());",
            "\t\treturn result;",
            "\t}",
            "",
            "   private:",
            "\tint n;",
            "\tvector<int> data;",
            "};",
        ]
    },
    "FenwickTree": {
        "prefix": "FenwickTree",
        "body": [
            "template <typename T>",
            "struct FenwickTree {",
            "\tFenwickTree(int N)",
            "\t\t: n(N), data(N) {}",
            "\tvoid add(int p, T x) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp++;",
            "\t\twhile(p <= n) {",
            "\t\t\tdata[p - 1] += x;",
            "\t\t\tp += p & -p;",
            "\t\t}",
            "\t}",
            "\tT sum(int l, int r) {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\treturn sum(r) - sum(l);",
            "\t}",
            "\tT operator[](int x) const {",
            "\t\tassert(0 <= x && x < n);",
            "\t\treturn sum(x, x + 1);",
            "\t}",
            "",
            "   private:",
            "\tint n;",
            "\tvector<T> data;",
            "\tinline T sum(int r) {",
            "\t\tT s = 0;",
            "\t\twhile(r > 0) {",
            "\t\t\ts += data[r - 1];",
            "\t\t\tr -= r & -r;",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "};",
        ]
    },
    "RangeMaximumQuery&RangeAddQuery": {
        "prefix": "RangeMaximumQuery&RangeAddQuery",
        "body": [
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "S op(S a, S b) {",
            "\treturn max(a, b);",
            "}",
            "S e() {",
            "\treturn -INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn f + x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}",
        ]
    },
    "RangeMaximumQuery&RangeUpdateQuery": {
        "prefix": "RangeMaximumQuery&RangeUpdateQuery",
        "body": [
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn max(a, b);",
            "}",
            "S e() {",
            "\treturn -INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn (f == ID ? x : f);",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}",
        ]
    },
    "RangeMinimumQuery&RangeAddQuery": {
        "prefix": "RangeMinimumQuery&RangeAddQuery",
        "body": [
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "S op(S a, S b) {",
            "\treturn min(a, b);",
            "}",
            "S e() {",
            "\treturn INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn f + x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}",
        ]
    },
    "RangeMinimumQuery&RangeUpdateQuery": {
        "prefix": "RangeMinimumQuery&RangeUpdateQuery",
        "body": [
            "using S = long long;",
            "using F = long long;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn min(a, b);",
            "}",
            "S e() {",
            "\treturn INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn (f == ID ? x : f);",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}",
        ]
    },
    "RangeSumQuery&RangeAddQuery": {
        "prefix": "RangeSumQuery&RangeAddQuery",
        "body": [
            "struct S {",
            "\tlong long value;",
            "\tlong long size;",
            "};",
            "using F = long long;",
            "S op(S a, S b) {",
            "\treturn {a.value + b.value, a.size + b.size};",
            "}",
            "S e() {",
            "\treturn {0, 0};",
            "}",
            "S mapping(F f, S x) {",
            "\treturn {x.value + f * x.size, x.size};",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}",
        ]
    },
    "RangeSumQuery&RangeUpdateQuery": {
        "prefix": "RangeSumQuery&RangeUpdateQuery",
        "body": [
            "struct S {",
            "\tlong long value;",
            "\tlong long size;",
            "};",
            "using F = long long;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn {a.value + b.value, a.size + b.size};",
            "}",
            "S e() {",
            "\treturn {0, 0};",
            "}",
            "S mapping(F f, S x) {",
            "\tif(f != ID) x.value = f * x.size;",
            "\treturn x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}",
        ]
    },
    "RotateVector": {
        "prefix": "RotateVector",
        "body": [
            "template <typename T>",
            "vector<vector<T>> rotate(vector<vector<T>> vec) {",
            "\tint n = vec.size(), m = vec[0].size();",
            "\tvector<vector<T>> res(m, vector<T>(n));",
            "\trep(i, 0, n) {",
            "\t\trep(j, 0, m) {",
            "\t\t\tres[j][n - 1 - i] = vec[i][j];",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}",
        ]
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "template <typename T>",
            "struct SparseTable {",
            "\tSparseTable(const vector<T>& v)",
            "\t\t: n((int)v.size()) {",
            "\t\tint b = 1;",
            "\t\twhile((1 << b) <= n) ++b;",
            "\t\ttable.push_back(v);",
            "\t\tfor(int i = 1; i < b; ++i) {",
            "\t\t\ttable.push_back(vector<T>(n, e()));",
            "\t\t\tfor(int j = 0; j + (1 << i) <= n; ++j) {",
            "\t\t\t\ttable[i][j] = op(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) const {",
            "\t\tassert(0 <= l and l <= r and r <= n);",
            "\t\tif(l == r) return e();",
            "\t\tint b = 31 - __builtin_clz(r - l);",
            "\t\treturn op(table[b][l], table[b][r - (1 << b)]);",
            "\t}",
            "",
            "   private:",
            "\tinline static constexpr T INF = numeric_limits<T>::max() / 2;",
            "\tint n;",
            "\tvector<vector<T>> table;",
            "\tinline T op(const T& a, const T& b) const {",
            "\t\treturn min(a, b);",
            "\t}",
            "\tinline T e() const {",
            "\t\treturn INF;",
            "\t}",
            "};",
        ]
    },
    "SparseTable2D": {
        "prefix": "SparseTable2D",
        "body": [
            "template <typename T>",
            "struct SparseTable2D {",
            "\tSparseTable2D(const vector<vector<T>>& v) {",
            "\t\th = v.size();",
            "\t\tw = v[0].size();",
            "\t\tLOG = vector<int>(max(h, w) + 1);",
            "\t\trep(i, 2, max(h, w) + 1) LOG[i] = LOG[i / 2] + 1;",
            "\t\ttable = vector<vector<vector<vector<T>>>>(LOG[h] + 1, vector<vector<vector<T>>>(LOG[w] + 1, vector<vector<T>>(h, vector<T>(w, e()))));",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tfor(int j = 0; j < w; ++j) {",
            "\t\t\t\ttable[0][0][i][j] = v[i][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(int i = 0; i <= LOG[h]; ++i) {",
            "\t\t\tfor(int j = 0; j <= LOG[w]; ++j) {",
            "\t\t\t\tfor(int x = 0; x < h; ++x) {",
            "\t\t\t\t\tfor(int y = 0; y < w; ++y) {",
            "\t\t\t\t\t\tif(i < LOG[h]) table[i + 1][j][x][y] = op(table[i][j][x][y], (x + (1 << i) < h) ? table[i][j][x + (1 << i)][y] : e());",
            "\t\t\t\t\t\tif(j < LOG[w]) table[i][j + 1][x][y] = op(table[i][j][x][y], (y + (1 << j) < w) ? table[i][j][x][y + (1 << j)] : e());",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tT query(int lx, int rx, int ly, int ry) const {",
            "\t\tassert(0 <= lx and lx <= rx and rx <= h);",
            "\t\tassert(0 <= ly and ly <= ry and ry <= w);",
            "\t\tif(lx == rx or ly == ry) return e();",
            "\t\tint kx = LOG[rx - lx];",
            "\t\tint ky = LOG[ry - ly];",
            "\t\treturn op(op(table[kx][ky][lx][ly], table[kx][ky][rx - (1 << kx)][ly]), op(table[kx][ky][lx][ry - (1 << ky)], table[kx][ky][rx - (1 << kx)][ry - (1 << ky)]));",
            "\t}",
            "",
            "   private:",
            "\tinline static constexpr T INF = numeric_limits<T>::max() / 2;",
            "\tint h, w;",
            "\tvector<vector<vector<vector<T>>>> table;",
            "\tvector<int> LOG;",
            "\tinline T op(const T& a, const T& b) const {",
            "\t\treturn min(a, b);",
            "\t};",
            "\tinline T e() const {",
            "\t\treturn INF;",
            "\t}",
            "};",
        ]
    },
    "Tree": {
        "prefix": "Tree",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#include <ext/pb_ds/tag_and_trait.hpp>",
            "using namespace __gnu_pbds;",
            "using Tree = tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>;  // set",
            "// using Tree = tree<ll,null_type,less_equal<ll>,rb_tree_tag,tree_order_statistics_node_update>; // multiset",
        ]
    },
    "Vector": {
        "prefix": "Vector",
        "body": [
            "const long double pi = acos(-1);",
            "const long double eps = 1e-7;",
            "struct V {",
            "\tlong double x, y;",
            "\tV(long double x = 0, long double y = 0)",
            "\t\t: x(x), y(y) {}",
            "\tV& operator+=(const V& v) {",
            "\t\tx += v.x;",
            "\t\ty += v.y;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator+(const V& v) const {",
            "\t\treturn V(*this) += v;",
            "\t}",
            "\tV& operator-=(const V& v) {",
            "\t\tx -= v.x;",
            "\t\ty -= v.y;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator-(const V& v) const {",
            "\t\treturn V(*this) -= v;",
            "\t}",
            "\tV& operator*=(long double s) {",
            "\t\tx *= s;",
            "\t\ty *= s;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator*(long double s) const {",
            "\t\treturn V(*this) *= s;",
            "\t}",
            "\tV& operator/=(long double s) {",
            "\t\tx /= s;",
            "\t\ty /= s;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator/(long double s) const {",
            "\t\treturn V(*this) /= s;",
            "\t}",
            "\tlong double dot(const V& v) const {",
            "\t\treturn x * v.x + y * v.y;",
            "\t}",
            "\tlong double cross(const V& v) const {",
            "\t\treturn x * v.y - v.x * y;",
            "\t}",
            "\tlong double norm2() const {",
            "\t\treturn x * x + y * y;",
            "\t}",
            "\tlong double norm() const {",
            "\t\treturn sqrtl(x * x + y * y);",
            "\t}",
            "\tlong double arg() const {",
            "\t\treturn atan2l(y, x);",
            "\t}",
            "\tV rotate() const {",
            "\t\treturn V(y, -x);",
            "\t}",
            "\tint ort() const {",
            "\t\tif(abs(x) < eps && abs(y) < eps) return 0;",
            "\t\tif(y > 0) return x > 0 ? 1 : 2;",
            "\t\telse return x > 0 ? 4 : 3;",
            "\t}",
            "\tinline bool operator<(const V& v) const {",
            "\t\tlong double theta = arg();",
            "\t\tlong double vtheta = v.arg();",
            "\t\treturn theta < vtheta;",
            "\t}",
            "\t// inline bool operator<(const V& v) const {",
            "\t//\t int o = ort(), vo = v.ort();",
            "\t//\t if(o != vo) return o < vo;",
            "\t//\t return cross(v) > 0;",
            "\t// }",
            "\t// inline bool operator<(const V& v) const {",
            "\t//\t if(x != v.x) return x < v.x;",
            "\t//\t return y < v.y;",
            "\t// }",
            "};",
            "vector<V> ConvexHull(const vector<V>& ps) {",
            "\tint n = (int)ps.size();",
            "\tif(n <= 2) return ps;",
            "\tvector<V> res(2 * n);",
            "\tint k = 0;",
            "\tfor(int i = 0; i < n; ++i) {",
            "\t\twhile(k > 1 and (res[k - 1] - res[k - 2]).cross(ps[i] - res[k - 1]) <= 0) --k;",
            "\t\tres[k++] = ps[i];",
            "\t}",
            "\tfor(int i = n - 2, t = k; i >= 0; --i) {",
            "\t\twhile(k > t and (res[k - 1] - res[k - 2]).cross(ps[i] - res[k - 1]) <= 0) --k;",
            "\t\tres[k++] = ps[i];",
            "\t}",
            "\tres.resize(k - 1);",
            "\treturn res;",
            "}",
        ]
    },
    "LowestCommonAncestor": {
        "prefix": "LowestCommonAncestor",
        "body": [
            "template <typename T>",
            "struct LowestCommonAncestor {",
            "\tLowestCommonAncestor(int n)",
            "\t\t: n(n), to(n), co(n), dep(n), costs(n) {",
            "\t\tl = 0;",
            "\t\twhile((1 << l) < n) ++l;",
            "\t\tpar = vector<vector<int>>(l, vector<int>(n + 1, n));",
            "\t}",
            "\tvoid add_edge(int a, int b, const T& c = 0) {",
            "\t\tassert(0 <= a and a < n and 0 <= b and b < n);",
            "\t\tto[a].push_back(b);",
            "\t\tco[a].push_back(c);",
            "\t\tto[b].push_back(a);",
            "\t\tco[b].push_back(c);",
            "\t}",
            "\tvoid init(int _root = 0) {",
            "\t\troot = _root;",
            "\t\tassert(0 <= root and root < n);",
            "\t\tdfs(root, 0, 0, n);",
            "\t\tfor(int i = 0; i < l - 1; ++i) {",
            "\t\t\tfor(int v = 0; v < n; ++v) {",
            "\t\t\t\tpar[i + 1][v] = par[i][par[i][v]];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tint parent(int a) const {",
            "\t\tassert(0 <= a and a < n);",
            "\t\treturn par[0][a];",
            "\t}",
            "\tint lca(int a, int b) const {",
            "\t\tassert(0 <= a and a < n and 0 <= b and b < n);",
            "\t\tif(dep[a] > dep[b]) swap(a, b);",
            "\t\tint gap = dep[b] - dep[a];",
            "\t\tfor(int i = l - 1; i >= 0; --i) {",
            "\t\t\tint len = 1 << i;",
            "\t\t\tif(gap >= len) {",
            "\t\t\t\tgap -= len;",
            "\t\t\t\tb = par[i][b];",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(a == b) return a;",
            "\t\tfor(int i = l - 1; i >= 0; --i) {",
            "\t\t\tint na = par[i][a];",
            "\t\t\tint nb = par[i][b];",
            "\t\t\tif(na != nb) a = na, b = nb;",
            "\t\t}",
            "\t\treturn par[0][a];",
            "\t}",
            "\tint length(int a, int b) const {",
            "\t\tassert(0 <= a and a < n and 0 <= b and b < n);",
            "\t\tint c = lca(a, b);",
            "\t\treturn dep[a] + dep[b] - dep[c] * 2;",
            "\t}",
            "\tT dist(int a, int b) const {",
            "\t\tassert(0 <= a and a < n and 0 <= b and b < n);",
            "\t\tint c = lca(a, b);",
            "\t\treturn costs[a] + costs[b] - costs[c] * 2;",
            "\t}",
            "",
            "   private:",
            "\tint n, root, l;",
            "\tvector<vector<int>> to;",
            "\tvector<vector<T>> co;",
            "\tvector<int> dep;",
            "\tvector<T> costs;",
            "\tvector<vector<int>> par;",
            "\tvoid dfs(int v, int d, T c, int p) {",
            "\t\tpar[0][v] = p;",
            "\t\tdep[v] = d;",
            "\t\tcosts[v] = c;",
            "\t\tfor(int i = 0; i < (int)to[v].size(); ++i) {",
            "\t\t\tint u = to[v][i];",
            "\t\t\tif(u == p) continue;",
            "\t\t\tdfs(u, d + 1, c + co[v][i], v);",
            "\t\t}",
            "\t}",
            "};",
        ]
    },
    "MaxFlow": {
        "prefix": "MaxFlow",
        "body": [
            "template <typename Cap>",
            "struct MaxFlow {",
            "\tMaxFlow(int N)",
            "\t\t: n(N), g(N) {}",
            "\tint add_edge(int from, int to, const Cap& cap) {",
            "\t\tassert(0 <= from and from < n);",
            "\t\tassert(0 <= to and to < n);",
            "\t\tassert(0 <= cap);",
            "\t\tint m = int(pos.size());",
            "\t\tpos.push_back({from, int(g[from].size())});",
            "\t\tint from_id = int(g[from].size());",
            "\t\tint to_id = int(g[to].size());",
            "\t\tif(from == to) ++to_id;",
            "\t\tg[from].push_back(_edge{to, to_id, cap});",
            "\t\tg[to].push_back(_edge{from, from_id, 0});",
            "\t\treturn m;",
            "\t}",
            "\tstruct edge {",
            "\t\tint from, to;",
            "\t\tCap cap, flow;",
            "\t};",
            "\tedge get_edge(int i) const {",
            "\t\tint m = int(pos.size());",
            "\t\tassert(0 <= i and i < m);",
            "\t\tauto _e = g[pos[i].first][pos[i].second];",
            "\t\tauto _re = g[_e.to][_e.rev];",
            "\t\treturn edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};",
            "\t}",
            "\tvector<edge> edges() const {",
            "\t\tint m = int(pos.size());",
            "\t\tvector<edge> result;",
            "\t\tfor(int i = 0; i < m; ++i) {",
            "\t\t\tresult.push_back(get_edge(i));",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "\tvoid change_edge(int i, const Cap& new_cap, const Cap& new_flow) {",
            "\t\tint m = int(pos.size());",
            "\t\tassert(0 <= i and i < m);",
            "\t\tassert(0 <= new_flow and new_flow <= new_cap);",
            "\t\tauto& _e = g[pos[i].first][pos[i].second];",
            "\t\tauto& _re = g[_e.to][_e.rev];",
            "\t\t_e.cap = new_cap - new_flow;",
            "\t\t_re.cap = new_flow;",
            "\t}",
            "\tCap flow(int s, int t) {",
            "\t\treturn flow(s, t, numeric_limits<Cap>::max());",
            "\t}",
            "\tCap flow(int s, int t, const Cap& flow_limit) {",
            "\t\tassert(0 <= s and s < n);",
            "\t\tassert(0 <= t and t < n);",
            "\t\tassert(s != t);",
            "\t\tvector<int> level(n), iter(n);",
            "\t\tqueue<int> que;",
            "\t\tauto bfs = [&]() -> void {",
            "\t\t\tfill(level.begin(), level.end(), -1);",
            "\t\t\tlevel[s] = 0;",
            "\t\t\tqueue<int>().swap(que);",
            "\t\t\tque.push(s);",
            "\t\t\twhile(!que.empty()) {",
            "\t\t\t\tint v = que.front();",
            "\t\t\t\tque.pop();",
            "\t\t\t\tfor(auto e : g[v]) {",
            "\t\t\t\t\tif(e.cap == 0 or level[e.to] >= 0) continue;",
            "\t\t\t\t\tlevel[e.to] = level[v] + 1;",
            "\t\t\t\t\tif(e.to == t) return;",
            "\t\t\t\t\tque.push(e.to);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t};",
            "\t\tauto dfs = [&](auto& dfs, int v, const Cap& up) -> Cap {",
            "\t\t\tif(v == s) return up;",
            "\t\t\tCap res = 0;",
            "\t\t\tint level_v = level[v];",
            "\t\t\tfor(int& i = iter[v]; i < int(g[v].size()); ++i) {",
            "\t\t\t\t_edge& e = g[v][i];",
            "\t\t\t\tif(level_v <= level[e.to] or g[e.to][e.rev].cap == 0) continue;",
            "\t\t\t\tCap d = dfs(dfs, e.to, min(up - res, g[e.to][e.rev].cap));",
            "\t\t\t\tif(d <= 0) continue;",
            "\t\t\t\tg[v][i].cap += d;",
            "\t\t\t\tg[e.to][e.rev].cap -= d;",
            "\t\t\t\tres += d;",
            "\t\t\t\tif(res == up) return res;",
            "\t\t\t}",
            "\t\t\tlevel[v] = n;",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tCap flow = 0;",
            "\t\twhile(flow < flow_limit) {",
            "\t\t\tbfs();",
            "\t\t\tif(level[t] == -1) break;",
            "\t\t\tfill(iter.begin(), iter.end(), 0);",
            "\t\t\tCap f = dfs(dfs, t, flow_limit - flow);",
            "\t\t\tif(!f) break;",
            "\t\t\tflow += f;",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\tvector<bool> min_cut(int s) const {",
            "\t\tvector<bool> visited(n);",
            "\t\tqueue<int> que;",
            "\t\tque.push(s);",
            "\t\twhile(!que.empty()) {",
            "\t\t\tint p = que.front();",
            "\t\t\tque.pop();",
            "\t\t\tvisited[p] = true;",
            "\t\t\tfor(auto e : g[p]) {",
            "\t\t\t\tif(e.cap and !visited[e.to]) {",
            "\t\t\t\t\tvisited[e.to] = true;",
            "\t\t\t\t\tque.push(e.to);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn visited;",
            "\t}",
            "",
            "   private:",
            "\tstruct _edge {",
            "\t\tint to, rev;",
            "\t\tCap cap;",
            "\t};",
            "\tint n;",
            "\tvector<pair<int, int>> pos;",
            "\tvector<vector<_edge>> g;",
            "};",
        ]
    },
    "MinCostFlow": {
        "prefix": "MinCostFlow",
        "body": [
            "namespace internal {",
            "template <class E>",
            "struct csr {",
            "\tstd::vector<int> start;",
            "\tstd::vector<E> elist;",
            "\texplicit csr(int n, const std::vector<std::pair<int, E>>& edges)",
            "\t\t: start(n + 1), elist(edges.size()) {",
            "\t\tfor(auto e : edges) {",
            "\t\t\t++start[e.first + 1];",
            "\t\t}",
            "\t\tfor(int i = 1; i <= n; ++i) {",
            "\t\t\tstart[i] += start[i - 1];",
            "\t\t}",
            "\t\tauto counter = start;",
            "\t\tfor(auto e : edges) {",
            "\t\t\telist[counter[e.first]++] = e.second;",
            "\t\t}",
            "\t}",
            "};",
            "template <class T>",
            "struct simple_queue {",
            "\tstd::vector<T> payload;",
            "\tint pos = 0;",
            "\tvoid reserve(int n) {",
            "\t\tpayload.reserve(n);",
            "\t}",
            "\tint size() const {",
            "\t\treturn int(payload.size()) - pos;",
            "\t}",
            "\tbool empty() const {",
            "\t\treturn pos == int(payload.size());",
            "\t}",
            "\tvoid push(const T& t) {",
            "\t\tpayload.push_back(t);",
            "\t}",
            "\tT& front() {",
            "\t\treturn payload[pos];",
            "\t}",
            "\tvoid clear() {",
            "\t\tpayload.clear();",
            "\t\tpos = 0;",
            "\t}",
            "\tvoid pop() {",
            "\t\t++pos;",
            "\t}",
            "};",
            "}  // namespace internal",
            "template <class Cap, class Cost>",
            "struct MinCostFlow {",
            "   public:",
            "\tMinCostFlow() {}",
            "\texplicit MinCostFlow(int n)",
            "\t\t: _n(n) {}",
            "\tint add_edge(int from, int to, const Cap& cap, const Cost& cost) {",
            "\t\tassert(0 <= from and from < _n);",
            "\t\tassert(0 <= to and to < _n);",
            "\t\tassert(0 <= cap);",
            "\t\tassert(0 <= cost);",
            "\t\tint m = int(_edges.size());",
            "\t\t_edges.push_back({from, to, cap, 0, cost});",
            "\t\treturn m;",
            "\t}",
            "\tstruct edge {",
            "\t\tint from, to;",
            "\t\tCap cap, flow;",
            "\t\tCost cost;",
            "\t};",
            "\tedge get_edge(int i) {",
            "\t\tint m = int(_edges.size());",
            "\t\tassert(0 <= i and i < m);",
            "\t\treturn _edges[i];",
            "\t}",
            "\tstd::vector<edge> edges() {",
            "\t\treturn _edges;",
            "\t}",
            "\tstd::pair<Cap, Cost> flow(int s, int t) {",
            "\t\treturn flow(s, t, std::numeric_limits<Cap>::max());",
            "\t}",
            "\tstd::pair<Cap, Cost> flow(int s, int t, const Cap& flow_limit) {",
            "\t\treturn slope(s, t, flow_limit).back();",
            "\t}",
            "\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t) {",
            "\t\treturn slope(s, t, std::numeric_limits<Cap>::max());",
            "\t}",
            "\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t, const Cap& flow_limit) {",
            "\t\tassert(0 <= s and s < _n);",
            "\t\tassert(0 <= t and t < _n);",
            "\t\tassert(s != t);",
            "\t\tint m = int(_edges.size());",
            "\t\tstd::vector<int> edge_idx(m);",
            "\t\tauto g = [&]() {",
            "\t\t\tstd::vector<int> degree(_n), redge_idx(m);",
            "\t\t\tstd::vector<std::pair<int, _edge>> elist;",
            "\t\t\telist.reserve(2 * m);",
            "\t\t\tfor(int i = 0; i < m; ++i) {",
            "\t\t\t\tauto e = _edges[i];",
            "\t\t\t\tedge_idx[i] = degree[e.from]++;",
            "\t\t\t\tredge_idx[i] = degree[e.to]++;",
            "\t\t\t\telist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});",
            "\t\t\t\telist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});",
            "\t\t\t}",
            "\t\t\tauto _g = internal::csr<_edge>(_n, elist);",
            "\t\t\tfor(int i = 0; i < m; ++i) {",
            "\t\t\t\tauto e = _edges[i];",
            "\t\t\t\tedge_idx[i] += _g.start[e.from];",
            "\t\t\t\tredge_idx[i] += _g.start[e.to];",
            "\t\t\t\t_g.elist[edge_idx[i]].rev = redge_idx[i];",
            "\t\t\t\t_g.elist[redge_idx[i]].rev = edge_idx[i];",
            "\t\t\t}",
            "\t\t\treturn _g;",
            "\t\t}();",
            "\t\tauto result = slope(g, s, t, flow_limit);",
            "\t\tfor(int i = 0; i < m; ++i) {",
            "\t\t\tauto e = g.elist[edge_idx[i]];",
            "\t\t\t_edges[i].flow = _edges[i].cap - e.cap;",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "",
            "   private:",
            "\tint _n;",
            "\tstd::vector<edge> _edges;",
            "\tstruct _edge {",
            "\t\tint to, rev;",
            "\t\tCap cap;",
            "\t\tCost cost;",
            "\t};",
            "\tstd::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,",
            "\t\t\t\t\t\t\t\t\t\t\tint s,",
            "\t\t\t\t\t\t\t\t\t\t\tint t,",
            "\t\t\t\t\t\t\t\t\t\t\tconst Cap& flow_limit) {",
            "\t\tstd::vector<std::pair<Cost, Cost>> dual_dist(_n);",
            "\t\tstd::vector<int> prev_e(_n);",
            "\t\tstd::vector<bool> vis(_n);",
            "\t\tstruct Q {",
            "\t\t\tCost key;",
            "\t\t\tint to;",
            "\t\t\tinline bool operator<(Q r) const {",
            "\t\t\t\treturn key > r.key;",
            "\t\t\t}",
            "\t\t};",
            "\t\tstd::vector<int> que_min;",
            "\t\tstd::vector<Q> que;",
            "\t\tauto dual_ref = [&]() {",
            "\t\t\tfor(int i = 0; i < _n; ++i) {",
            "\t\t\t\tdual_dist[i].second = std::numeric_limits<Cost>::max();",
            "\t\t\t}",
            "\t\t\tstd::fill(vis.begin(), vis.end(), false);",
            "\t\t\tque_min.clear();",
            "\t\t\tque.clear();",
            "\t\t\tsize_t heap_r = 0;",
            "\t\t\tdual_dist[s].second = 0;",
            "\t\t\tque_min.push_back(s);",
            "\t\t\twhile(!que_min.empty() or !que.empty()) {",
            "\t\t\t\tint v;",
            "\t\t\t\tif(!que_min.empty()) {",
            "\t\t\t\t\tv = que_min.back();",
            "\t\t\t\t\tque_min.pop_back();",
            "\t\t\t\t} else {",
            "\t\t\t\t\twhile(heap_r < que.size()) {",
            "\t\t\t\t\t\t++heap_r;",
            "\t\t\t\t\t\tstd::push_heap(que.begin(), que.begin() + heap_r);",
            "\t\t\t\t\t}",
            "\t\t\t\t\tv = que.front().to;",
            "\t\t\t\t\tstd::pop_heap(que.begin(), que.end());",
            "\t\t\t\t\tque.pop_back();",
            "\t\t\t\t\t--heap_r;",
            "\t\t\t\t}",
            "\t\t\t\tif(vis[v]) continue;",
            "\t\t\t\tvis[v] = true;",
            "\t\t\t\tif(v == t) break;",
            "\t\t\t\tCost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;",
            "\t\t\t\tfor(int i = g.start[v]; i < g.start[v + 1]; ++i) {",
            "\t\t\t\t\tauto e = g.elist[i];",
            "\t\t\t\t\tif(!e.cap) continue;",
            "\t\t\t\t\tCost cost = e.cost - dual_dist[e.to].first + dual_v;",
            "\t\t\t\t\tif(dual_dist[e.to].second - dist_v > cost) {",
            "\t\t\t\t\t\tCost dist_to = dist_v + cost;",
            "\t\t\t\t\t\tdual_dist[e.to].second = dist_to;",
            "\t\t\t\t\t\tprev_e[e.to] = e.rev;",
            "\t\t\t\t\t\tif(dist_to == dist_v) {",
            "\t\t\t\t\t\t\tque_min.push_back(e.to);",
            "\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\tque.push_back(Q{dist_to, e.to});",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(!vis[t]) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tfor(int v = 0; v < _n; ++v) {",
            "\t\t\t\tif(!vis[v]) continue;",
            "\t\t\t\tdual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;",
            "\t\t\t}",
            "\t\t\treturn true;",
            "\t\t};",
            "\t\tCap flow = 0;",
            "\t\tCost cost = 0, prev_cost_per_flow = -1;",
            "\t\tstd::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};",
            "\t\twhile(flow < flow_limit) {",
            "\t\t\tif(!dual_ref()) break;",
            "\t\t\tCap c = flow_limit - flow;",
            "\t\t\tfor(int v = t; v != s; v = g.elist[prev_e[v]].to) {",
            "\t\t\t\tc = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);",
            "\t\t\t}",
            "\t\t\tfor(int v = t; v != s; v = g.elist[prev_e[v]].to) {",
            "\t\t\t\tauto& e = g.elist[prev_e[v]];",
            "\t\t\t\te.cap += c;",
            "\t\t\t\tg.elist[e.rev].cap -= c;",
            "\t\t\t}",
            "\t\t\tCost d = -dual_dist[s].first;",
            "\t\t\tflow += c;",
            "\t\t\tcost += c * d;",
            "\t\t\tif(prev_cost_per_flow == d) {",
            "\t\t\t\tresult.pop_back();",
            "\t\t\t}",
            "\t\t\tresult.push_back({flow, cost});",
            "\t\t\tprev_cost_per_flow = d;",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "};",
        ]
    },
    "TreeDiameter": {
        "prefix": "TreeDiameter",
        "body": [
            "template <typename T>",
            "struct TreeDiameter {",
            "\tTreeDiameter(int n)",
            "\t\t: n(n), to(n), cost(n) {}",
            "\tvoid add_edge(int u, int v, const T& c = 1) {",
            "\t\tto[u].push_back(v);",
            "\t\tto[v].push_back(u);",
            "\t\tcost[u].push_back(c);",
            "\t\tcost[v].push_back(c);",
            "\t}",
            "\tpair<T, vector<int>> diameter() {",
            "\t\tvector<T> dist(n);",
            "\t\tvector<int> par(n);",
            "\t\tauto dfs = [&](auto& dfs, int v, int p, const T& dep) -> void {",
            "\t\t\tdist[v] = dep;",
            "\t\t\tpar[v] = p;",
            "\t\t\tfor(int i = 0; i < (int)to[v].size(); ++i) {",
            "\t\t\t\tif(to[v][i] == p) continue;",
            "\t\t\t\tdfs(dfs, to[v][i], v, dep + cost[v][i]);",
            "\t\t\t}",
            "\t\t};",
            "\t\tdfs(dfs, 0, -1, 0);",
            "\t\tint s = -1;",
            "\t\tT ma = -1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tif(ma < dist[i]) {",
            "\t\t\t\ts = i;",
            "\t\t\t\tma = dist[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tdfs(dfs, s, -1, 0);",
            "\t\tint t = -1;",
            "\t\tma = -1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tif(ma < dist[i]) {",
            "\t\t\t\tt = i;",
            "\t\t\t\tma = dist[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<int> vec;",
            "\t\tint cur = t;",
            "\t\twhile(cur != -1) {",
            "\t\t\tvec.push_back(cur);",
            "\t\t\tcur = par[cur];",
            "\t\t}",
            "\t\treturn {ma, vec};",
            "\t}",
            "",
            "   private:",
            "\tint n;",
            "\tvector<vector<int>> to;",
            "\tvector<vector<T>> cost;",
            "};",
        ]
    },
    "Binomial": {
        "prefix": "Binomial",
        "body": [
            "struct Binomial {",
            "\tBinomial(int n)",
            "\t\t: fac(n + 1), ifac(n + 1) {",
            "\t\tfac[0] = 1;",
            "\t\tfor(int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i;",
            "\t\tifac[n] = fac[n].inv();",
            "\t\tfor(int i = n; i >= 1; --i) ifac[i - 1] = ifac[i] * i;",
            "\t}",
            "\tmint fact(int n) {",
            "\t\tif(n < 0) return 0;",
            "\t\treturn fac[n];",
            "\t}",
            "\tmint perm(int n, int r) {",
            "\t\tif(n < 0 or n < r or r < 0) return 0;",
            "\t\treturn fac[n] * ifac[n - r];",
            "\t}",
            "\tmint comb(int n, int r) {",
            "\t\tif(n < 0 or n < r or r < 0) return 0;",
            "\t\treturn fac[n] * ifac[n - r] * ifac[r];",
            "\t}",
            "\tmint homo(int n, int r) {",
            "\t\tif(n < 0 or r < 0) return 0;",
            "\t\tif(r == 0) return 1;",
            "\t\treturn comb(n + r - 1, r);",
            "\t}",
            "\tmint operator()(int n, int r) {",
            "\t\treturn comb(n, r);",
            "\t}",
            "",
            "   private:",
            "\tvector<mint> fac, ifac;",
            "} binom(1000005);",
        ]
    },
    "ConvolutionArbitary": {
        "prefix": "ConvolutionArbitary",
        "body": [
            "template <class mint, internal::is_static_modint_t<mint>* = nullptr>",
            "vector<mint> convolution_arbitary(const vector<mint>& a, const vector<mint>& b) {",
            "\tint n = (int)a.size(), m = (int)b.size();",
            "\tstatic constexpr ll MOD1 = 754974721;",
            "\tstatic constexpr ll MOD2 = 167772161;",
            "\tstatic constexpr ll MOD3 = 469762049;",
            "\tstatic constexpr ll M1_inv_M2 = internal::inv_gcd(MOD1, MOD2).second;",
            "\tstatic constexpr ll M12_inv_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;",
            "\tstatic constexpr ll M12_mod = (MOD1 * MOD2) % mint::mod();",
            "\tvector<ll> a_(n), b_(m);",
            "\tfor(int i = 0; i < n; ++i) a_[i] = a[i].val();",
            "\tfor(int i = 0; i < m; ++i) b_[i] = b[i].val();",
            "\tvector<ll> x = convolution<MOD1>(a_, b_);",
            "\tvector<ll> y = convolution<MOD2>(a_, b_);",
            "\tvector<ll> z = convolution<MOD3>(a_, b_);",
            "\tvector<mint> c(n + m - 1);",
            "\tfor(int i = 0; i < n + m - 1; ++i) {",
            "\t\tll v1 = (y[i] - x[i]) * M1_inv_M2 % MOD2;",
            "\t\tif(v1 < 0) v1 += MOD2;",
            "\t\tll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_inv_M3 % MOD3;",
            "\t\tif(v2 < 0) v2 += MOD3;",
            "\t\tc[i] = x[i] + MOD1 * v1 + M12_mod * v2;",
            "\t}",
            "\treturn c;",
            "}",
        ]
    },
    "Divisor": {
        "prefix": "Divisor",
        "body": [
            "vector<ll> divisor(ll n) {",
            "\tvector<ll> res;",
            "\tfor(ll i = 1; i * i <= n; ++i) {",
            "\t\tif(n % i == 0) {",
            "\t\t\tres.push_back(i);",
            "\t\t\tif(i != n / i) res.push_back(n / i);",
            "\t\t}",
            "\t}",
            "\tranges::sort(res);",
            "\treturn res;",
            "}",
        ]
    },
    "EratosthenesSeive": {
        "prefix": "EratosthenesSeive",
        "body": [
            "vector<ll> prime;",
            "vector<bool> is_prime;",
            "void seive(ll n) {",
            "\tis_prime.resize(n + 1, true);",
            "\tis_prime[0] = is_prime[1] = false;",
            "\tfor(ll i = 2; i <= n; ++i) {",
            "\t\tif(is_prime[i]) {",
            "\t\t\tprime.push_back(i);",
            "\t\t\tfor(ll j = 2 * i; j <= n; j += i) {",
            "\t\t\t\tis_prime[j] = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
        ]
    },
    "FormalPowerSeries": {
        "prefix": "FormalPowerSeries",
        "body": [
            "template <class T>",
            "struct FormalPowerSeries : vector<T> {",
            "\tusing vector<T>::vector;",
            "\tusing F = FormalPowerSeries;",
            "\tF &operator=(const vector<T> &g) {",
            "\t\tconst int n = g.size();",
            "\t\tconst int m = (*this).size();",
            "\t\tif(m < n) (*this).resize(n);",
            "\t\tfor(int i = 0; i < n; ++i) (*this)[i] = g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-() {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= -1;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; ++i) (*this)[i] += g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] += r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; ++i) (*this)[i] -= g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] -= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const F &g) {",
            "\t\t(*this) = convolution((*this), g);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const T &r) {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this) = convolution((*this), g.inv());",
            "\t\t(*this).resize(n);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const T &r) {",
            "\t\tT inv_r = r.inv();",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= inv_r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator<<=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).insert((*this).begin(), d, 0);",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF &operator>>=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).erase((*this).begin(), (*this).begin() + min(n, d));",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF operator*(const T &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const T &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const T &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const T &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator*(const F &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const F &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const F &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const F &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator%(const F &g) const {",
            "\t\treturn F(*this) %= g;",
            "\t}",
            "\tF operator<<(const int d) const {",
            "\t\treturn F(*this) <<= d;",
            "\t}",
            "\tF operator>>(const int d) const {",
            "\t\treturn F(*this) >>= d;",
            "\t}",
            "\tF pre(const int sz) const {",
            "\t\treturn F(begin(*this), begin(*this) + min((int)this->size(), sz));",
            "\t}",
            "\tF inv(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n > 0 and (*this)[0] != T(0));",
            "\t\tF g(1);",
            "\t\tg[0] = (*this)[0].inv();",
            "\t\twhile((int)g.size() < deg) {",
            "\t\t\tint m = g.size();",
            "\t\t\tF f(begin(*this), begin(*this) + min(n, 2 * m));",
            "\t\t\tF r(g);",
            "\t\t\tf.resize(2 * m);",
            "\t\t\tr.resize(2 * m);",
            "\t\t\tinternal::butterfly(f);",
            "\t\t\tinternal::butterfly(r);",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) f[i] *= r[i];",
            "\t\t\tinternal::butterfly_inv(f);",
            "\t\t\tf.erase(f.begin(), f.begin() + m);",
            "\t\t\tf.resize(2 * m);",
            "\t\t\tinternal::butterfly(f);",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) f[i] *= r[i];",
            "\t\t\tinternal::butterfly_inv(f);",
            "\t\t\tT in = T(2 * m).inv();",
            "\t\t\tin *= -in;",
            "\t\t\tfor(int i = 0; i < m; ++i) f[i] *= in;",
            "\t\t\tg.insert(g.end(), f.begin(), f.begin() + m);",
            "\t\t}",
            "\t\treturn g.pre(deg);",
            "\t}",
            "\tT eval(const T &a) const {",
            "\t\tT x = 1;",
            "\t\tT ret = 0;",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) {",
            "\t\t\tret += (*this)[i] * x;",
            "\t\t\tx *= a;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\tvoid onemul(const int d, const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = n - d - 1; i >= 0; --i) {",
            "\t\t\t(*this)[i + d] += (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tvoid onediv(const int d, const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = 0; i < n - d; ++i) {",
            "\t\t\t(*this)[i + d] -= (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tF diff() const {",
            "\t\tconst int n = (*this).size();",
            "\t\tF ret(n);",
            "\t\tfor(int i = 1; i < n; ++i) ret[i - 1] = (*this)[i] * i;",
            "\t\tret[n - 1] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF integral() const {",
            "\t\tconst int n = (*this).size(), mod = T::mod();",
            "\t\tvector<T> inv(n);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i < n; ++i) inv[i] = T(mod) - inv[mod % i] * (mod / i);",
            "\t\tF ret(n);",
            "\t\tfor(int i = n - 2; i >= 0; --i) ret[i + 1] = (*this)[i] * inv[i + 1];",
            "\t\tret[0] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF log(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert((*this)[0] == T(1));",
            "\t\treturn ((*this).diff() * (*this).inv(deg)).pre(deg).integral();",
            "\t}",
            "\tF exp(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n == 0 or (*this)[0] == 0);",
            "\t\tF Inv;",
            "\t\tInv.reserve(deg);",
            "\t\tInv.push_back(T(0));",
            "\t\tInv.push_back(T(1));",
            "\t\tauto inplace_integral = [&](F &f) -> void {",
            "\t\t\tconst int n = (int)f.size();",
            "\t\t\tint mod = T::mod();",
            "\t\t\twhile((int)Inv.size() <= n) {",
            "\t\t\t\tint i = Inv.size();",
            "\t\t\t\tInv.push_back((-Inv[mod % i]) * (mod / i));",
            "\t\t\t}",
            "\t\t\tf.insert(begin(f), T(0));",
            "\t\t\tfor(int i = 1; i <= n; ++i) f[i] *= Inv[i];",
            "\t\t};",
            "\t\tauto inplace_diff = [](F &f) -> void {",
            "\t\t\tif(f.empty()) return;",
            "\t\t\tf.erase(begin(f));",
            "\t\t\tT coeff = 1;",
            "\t\t\tfor(int i = 0; i < (int)f.size(); ++i) {",
            "\t\t\t\tf[i] *= coeff;",
            "\t\t\t\t++coeff;",
            "\t\t\t}",
            "\t\t};",
            "\t\tF b{1, 1 < (int)(*this).size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};",
            "\t\tfor(int m = 2; m <= deg; m <<= 1) {",
            "\t\t\tauto y = b;",
            "\t\t\ty.resize(2 * m);",
            "\t\t\tinternal::butterfly(y);",
            "\t\t\tz1 = z2;",
            "\t\t\tF z(m);",
            "\t\t\tfor(int i = 0; i < m; ++i) z[i] = y[i] * z1[i];",
            "\t\t\tinternal::butterfly_inv(z);",
            "\t\t\tT si = T(m).inv();",
            "\t\t\tfor(int i = 0; i < m; ++i) z[i] *= si;",
            "\t\t\tfill(begin(z), begin(z) + m / 2, T(0));",
            "\t\t\tinternal::butterfly(z);",
            "\t\t\tfor(int i = 0; i < m; ++i) z[i] *= -z1[i];",
            "\t\t\tinternal::butterfly_inv(z);",
            "\t\t\tfor(int i = 0; i < m; ++i) z[i] *= si;",
            "\t\t\tc.insert(end(c), begin(z) + m / 2, end(z));",
            "\t\t\tz2 = c;",
            "\t\t\tz2.resize(2 * m);",
            "\t\t\tinternal::butterfly(z2);",
            "\t\t\tF x(begin((*this)), begin((*this)) + min<int>((*this).size(), m));",
            "\t\t\tx.resize(m);",
            "\t\t\tinplace_diff(x);",
            "\t\t\tx.push_back(T(0));",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < m; ++i) x[i] *= y[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tfor(int i = 0; i < m; ++i) x[i] *= si;",
            "\t\t\tx -= b.diff();",
            "\t\t\tx.resize(2 * m);",
            "\t\t\tfor(int i = 0; i < m - 1; ++i) x[m + i] = x[i], x[i] = T(0);",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) x[i] *= z2[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tT si2 = T(m << 1).inv();",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) x[i] *= si2;",
            "\t\t\tx.pop_back();",
            "\t\t\tinplace_integral(x);",
            "\t\t\tfor(int i = m; i < min<int>((*this).size(), 2 * m); ++i) x[i] += (*this)[i];",
            "\t\t\tfill(begin(x), begin(x) + m, T(0));",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) x[i] *= y[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; ++i) x[i] *= si2;",
            "\t\t\tb.insert(end(b), begin(x) + m, end(x));",
            "\t\t}",
            "\t\treturn b.pre(deg);",
            "\t}",
            "\tF pow(const ll k, int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tif(k == 0) {",
            "\t\t\tF ret(deg);",
            "\t\t\tif(deg) ret[0] = 1;",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tif((*this)[i] != T(0)) {",
            "\t\t\t\tT rev = T(1) / (*this)[i];",
            "\t\t\t\tF ret = (((*this * rev) >> i).log(deg) * k).exp(deg);",
            "\t\t\t\tret *= (*this)[i].pow(k);",
            "\t\t\t\tret = (ret << (i * k)).pre(deg);",
            "\t\t\t\tif((int)ret.size() < deg) ret.resize(deg, T(0));",
            "\t\t\t\treturn ret;",
            "\t\t\t}",
            "\t\t\tif(__int128_t(i + 1) * k >= deg) return F(deg, T(0));",
            "\t\t}",
            "\t\treturn F(deg, T(0));",
            "\t}",
            "\tF shift(const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int mod = T::mod();",
            "\t\tvector<T> inv(n + 1);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i <= n; ++i) inv[i] = mod - inv[mod % i] * (mod / i);",
            "\t\tT x = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\t(*this)[i] *= x;",
            "\t\t\tx *= (i + 1);",
            "\t\t}",
            "\t\tF g(n);",
            "\t\tT y = 1;",
            "\t\tT now = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tg[n - i - 1] = now * y;",
            "\t\t\tnow *= c;",
            "\t\t\ty *= inv[i + 1];",
            "\t\t}",
            "\t\tauto tmp = convolution(g, (*this));",
            "\t\tT z = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\t(*this)[i] = tmp[n + i - 1] * z;",
            "\t\t\tz *= inv[i + 1];",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "};",
        ]
    },
    "FormalPowerSeriesArbitary": {
        "prefix": "FormalPowerSeriesArbitary",
        "body": [
            "template <class mint, internal::is_static_modint_t<mint> * = nullptr>",
            "vector<mint> convolution_arbitary(const vector<mint> &a, const vector<mint> &b) {",
            "\tint n = (int)a.size(), m = (int)b.size();",
            "\tstatic constexpr ll MOD1 = 754974721;",
            "\tstatic constexpr ll MOD2 = 167772161;",
            "\tstatic constexpr ll MOD3 = 469762049;",
            "\tstatic constexpr ll M1_inv_M2 = internal::inv_gcd(MOD1, MOD2).second;",
            "\tstatic constexpr ll M12_inv_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;",
            "\tstatic constexpr ll M12_mod = (MOD1 * MOD2) % mint::mod();",
            "\tvector<ll> a_(n), b_(m);",
            "\tfor(int i = 0; i < n; ++i) a_[i] = a[i].val();",
            "\tfor(int i = 0; i < m; ++i) b_[i] = b[i].val();",
            "\tvector<ll> x = convolution<MOD1>(a_, b_);",
            "\tvector<ll> y = convolution<MOD2>(a_, b_);",
            "\tvector<ll> z = convolution<MOD3>(a_, b_);",
            "\tvector<mint> c(n + m - 1);",
            "\tfor(int i = 0; i < n + m - 1; ++i) {",
            "\t\tll v1 = (y[i] - x[i]) * M1_inv_M2 % MOD2;",
            "\t\tif(v1 < 0) v1 += MOD2;",
            "\t\tll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_inv_M3 % MOD3;",
            "\t\tif(v2 < 0) v2 += MOD3;",
            "\t\tc[i] = x[i] + MOD1 * v1 + M12_mod * v2;",
            "\t}",
            "\treturn c;",
            "}",
            "template <class T>",
            "struct FormalPowerSeries : vector<T> {",
            "\tusing vector<T>::vector;",
            "\tusing F = FormalPowerSeries;",
            "\tF &operator=(const vector<T> &g) {",
            "\t\tconst int n = g.size();",
            "\t\tconst int m = (*this).size();",
            "\t\tif(m < n) (*this).resize(n);",
            "\t\tfor(int i = 0; i < n; ++i) (*this)[i] = g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-() {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= -1;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; ++i) (*this)[i] += g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] += r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; ++i) (*this)[i] -= g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] -= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const F &g) {",
            "\t\t(*this) = convolution_arbitary((*this), g);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const T &r) {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this) = convolution_arbitary((*this), g.inv());",
            "\t\t(*this).resize(n);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const T &r) {",
            "\t\tT inv_r = r.inv();",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) (*this)[i] *= inv_r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator<<=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).insert((*this).begin(), d, 0);",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF &operator>>=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).erase((*this).begin(), (*this).begin() + min(n, d));",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF operator*(const T &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const T &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const T &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const T &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator*(const F &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const F &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const F &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const F &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator%(const F &g) const {",
            "\t\treturn F(*this) %= g;",
            "\t}",
            "\tF operator<<(const int d) const {",
            "\t\treturn F(*this) <<= d;",
            "\t}",
            "\tF operator>>(const int d) const {",
            "\t\treturn F(*this) >>= d;",
            "\t}",
            "\tF pre(const int sz) const {",
            "\t\treturn F(begin(*this), begin(*this) + min((int)this->size(), sz));",
            "\t}",
            "\tF inv(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n > 0 and (*this)[0] != T(0));",
            "\t\tF ret({T(1) / (*this)[0]});",
            "\t\tfor(int i = 1; i < deg; i <<= 1) {",
            "\t\t\tret = (ret + ret - ret * ret * (*this).pre(i << 1)).pre(i << 1);",
            "\t\t}",
            "\t\treturn ret.pre(deg);",
            "\t}",
            "\tT eval(const T &a) const {",
            "\t\tT x = 1;",
            "\t\tT ret = 0;",
            "\t\tfor(int i = 0; i < (int)(*this).size(); ++i) {",
            "\t\t\tret += (*this)[i] * x;",
            "\t\t\tx *= a;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\tvoid onemul(const int d, const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = n - d - 1; i >= 0; --i) {",
            "\t\t\t(*this)[i + d] += (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tvoid onediv(const int d, const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = 0; i < n - d; ++i) {",
            "\t\t\t(*this)[i + d] -= (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tF diff() const {",
            "\t\tconst int n = (*this).size();",
            "\t\tF ret(n);",
            "\t\tfor(int i = 1; i < n; ++i) ret[i - 1] = (*this)[i] * i;",
            "\t\tret[n - 1] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF integral() const {",
            "\t\tconst int n = (*this).size(), mod = T::mod();",
            "\t\tvector<T> inv(n);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i < n; ++i) inv[i] = T(mod) - inv[mod % i] * (mod / i);",
            "\t\tF ret(n);",
            "\t\tfor(int i = n - 2; i >= 0; --i) ret[i + 1] = (*this)[i] * inv[i + 1];",
            "\t\tret[0] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF log(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert((*this)[0] == T(1));",
            "\t\treturn ((*this).diff() * (*this).inv(deg)).pre(deg).integral();",
            "\t}",
            "\tF exp(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n == 0 or (*this)[0] == T(0));",
            "\t\tF ret({T(1)});",
            "\t\tfor(int i = 1; i < deg; i <<= 1) {",
            "\t\t\tret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);",
            "\t\t}",
            "\t\treturn ret.pre(deg);",
            "\t}",
            "\tF pow(const ll k, int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tif(k == 0) {",
            "\t\t\tF ret(deg);",
            "\t\t\tif(deg) ret[0] = 1;",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tif((*this)[i] != T(0)) {",
            "\t\t\t\tT rev = T(1) / (*this)[i];",
            "\t\t\t\tF ret = (((*this * rev) >> i).log(deg) * k).exp(deg);",
            "\t\t\t\tret *= (*this)[i].pow(k);",
            "\t\t\t\tret = (ret << (i * k)).pre(deg);",
            "\t\t\t\tif((int)ret.size() < deg) ret.resize(deg, T(0));",
            "\t\t\t\treturn ret;",
            "\t\t\t}",
            "\t\t\tif(__int128_t(i + 1) * k >= deg) return F(deg, T(0));",
            "\t\t}",
            "\t\treturn F(deg, T(0));",
            "\t}",
            "\tF shift(const T &c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int mod = T::mod();",
            "\t\tvector<T> inv(n + 1);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i <= n; ++i) inv[i] = mod - inv[mod % i] * (mod / i);",
            "\t\tT x = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\t(*this)[i] *= x;",
            "\t\t\tx *= (i + 1);",
            "\t\t}",
            "\t\tF g(n);",
            "\t\tT y = 1;",
            "\t\tT now = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\tg[n - i - 1] = now * y;",
            "\t\t\tnow *= c;",
            "\t\t\ty *= inv[i + 1];",
            "\t\t}",
            "\t\tauto tmp = convolution_arbitary(g, (*this));",
            "\t\tT z = 1;",
            "\t\tfor(int i = 0; i < n; ++i) {",
            "\t\t\t(*this)[i] = tmp[n + i - 1] * z;",
            "\t\t\tz *= inv[i + 1];",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "};",
        ]
    },
    "Lucas": {
        "prefix": "Lucas",
        "body": [
            "struct Lucas {",
            "\tLucas(int p)",
            "\t\t: mod(p), fact(p), ifact(p) {",
            "\t\tfact[0] = 1;",
            "\t\tfor(int i = 1; i < p; ++i) fact[i] = fact[i - 1] * i;",
            "\t\tifact[p - 1] = fact[p - 1].inv();",
            "\t\tfor(int i = p - 1; i >= 1; --i) ifact[i - 1] = ifact[i] * i;",
            "\t}",
            "\tmint operator()(ll n, ll k) {",
            "\t\tif(k < 0 or k > n) return 0;",
            "\t\tmint res = 1;",
            "\t\twhile(n > 0) {",
            "\t\t\tll n0 = n % mod, k0 = k % mod;",
            "\t\t\tif(n0 < k0) return 0;",
            "\t\t\tres *= fact[n0] * ifact[k0] * ifact[n0 - k0];",
            "\t\t\tn /= mod;",
            "\t\t\tk /= mod;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "   private:",
            "\tint mod;",
            "\tvector<mint> fact, ifact;",
            "};",
        ]
    },
    "Matrix": {
        "prefix": "Matrix",
        "body": [
            "template <typename T>",
            "struct Matrix {",
            "\tMatrix(int h, int w, T val = 0)",
            "\t\t: h(h), w(w), A(h, vector<T>(w, val)) {}",
            "\tint H() const {",
            "\t\treturn h;",
            "\t}",
            "\tint W() const {",
            "\t\treturn w;",
            "\t}",
            "\tinline const vector<T>& operator[](int i) const {",
            "\t\treturn A[i];",
            "\t}",
            "\tinline vector<T>& operator[](int i) {",
            "\t\treturn A[i];",
            "\t}",
            "\tstatic Matrix I(int n) {",
            "\t\tMatrix mat(n, n);",
            "\t\tfor(int i = 0; i < n; ++i) mat[i][i] = 1;",
            "\t\treturn mat;",
            "\t}",
            "\tMatrix& operator+=(const Matrix& B) {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tfor(int j = 0; j < w; ++j) {",
            "\t\t\t\t(*this)[i][j] += B[i][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix& operator-=(const Matrix& B) {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tfor(int j = 0; j < w; ++j) {",
            "\t\t\t\t(*this)[i][j] -= B[i][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix& operator*=(const Matrix& B) {",
            "\t\tassert(w == B.h);",
            "\t\tvector<vector<T>> C(h, vector<T>(B.w, 0));",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tfor(int k = 0; k < w; ++k) {",
            "\t\t\t\tfor(int j = 0; j < B.w; ++j) {",
            "\t\t\t\t\tC[i][j] += (*this)[i][k] * B[k][j];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tA.swap(C);",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix& pow(ll t) {",
            "\t\tassert(h == w);",
            "\t\tMatrix B = Matrix::I(h);",
            "\t\twhile(t > 0) {",
            "\t\t\tif(t & 1ll) B *= (*this);",
            "\t\t\t(*this) *= (*this);",
            "\t\t\tt >>= 1ll;",
            "\t\t}",
            "\t\tA.swap(B.A);",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix operator+(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) += B);",
            "\t}",
            "\tMatrix operator-(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) -= B);",
            "\t}",
            "\tMatrix operator*(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) *= B);",
            "\t}",
            "\tbool operator==(const Matrix& B) const {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\trep(i, 0, h) {",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\tif(A[i][j] != B[i][j]) return false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tbool operator!=(const Matrix& B) const {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tfor(int j = 0; j < w; ++j) {",
            "\t\t\t\tif(A[i][j] != B[i][j]) return true;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tT determinant() const {",
            "\t\tassert(h == w);",
            "\t\tMatrix B(*this);",
            "\t\tT res = 1;",
            "\t\tfor(int i = 0; i < h; ++i) {",
            "\t\t\tint idx = -1;",
            "\t\t\tfor(int j = i; j < w; ++j) {",
            "\t\t\t\tif(B[j][i] != 0) {",
            "\t\t\t\t\tidx = j;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(idx == -1) return 0;",
            "\t\t\tif(i != idx) {",
            "\t\t\t\tres *= T(-1);",
            "\t\t\t\tswap(B[i], B[idx]);",
            "\t\t\t}",
            "\t\t\tres *= B[i][i];",
            "\t\t\tT inv = T(1) / B[i][i];",
            "\t\t\tfor(int j = 0; j < w; ++j) {",
            "\t\t\t\tB[i][j] *= inv;",
            "\t\t\t}",
            "\t\t\tfor(int j = i + 1; j < h; ++j) {",
            "\t\t\t\tT a = B[j][i];",
            "\t\t\t\tif(a == 0) continue;",
            "\t\t\t\tfor(int k = i; k < w; ++k) {",
            "\t\t\t\t\tB[j][k] -= B[i][k] * a;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "   private:",
            "\tint h, w;",
            "\tvector<vector<T>> A;",
            "};",
        ]
    },
    "PrimalityTest": {
        "prefix": "PrimalityTest",
        "body": [
            "bool is_prime(ll n) {",
            "\tif(n == 1) return false;",
            "\tfor(ll i = 2; i * i <= n; ++i) {",
            "\t\tif(n % i == 0) return false;",
            "\t}",
            "\treturn true;",
            "}",
        ]
    },
    "PrimeFactorization": {
        "prefix": "PrimeFactorization",
        "body": [
            "map<ll, ll> prime_factor(ll n) {",
            "\tmap<ll, ll> res;",
            "\tfor(ll i = 2; i * i <= n; ++i) {",
            "\t\twhile(n % i == 0) {",
            "\t\t\t++res[i];",
            "\t\t\tn = n / i;",
            "\t\t}",
            "\t}",
            "\tif(n != 1) {",
            "\t\tres[n] = 1;",
            "\t}",
            "\treturn res;",
            "}",
        ]
    },
    "RungeKutta": {
        "prefix": "RungeKutta",
        "body": [
            "struct RungeKutta : vector<double> {",
            "\tusing vector<double>::vector;",
            "\tRungeKutta& operator+=(const RungeKutta& v) {",
            "\t\tfor(int i = 0; i < (int)this->size(); i++) {",
            "\t\t\t(*this)[i] += v[i];",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tRungeKutta operator+(const RungeKutta& v) {",
            "\t\treturn (RungeKutta)(*this) += v;",
            "\t}",
            "\tRungeKutta& operator*=(const double& k) {",
            "\t\tfor(int i = 0; i < (int)this->size(); i++) {",
            "\t\t\t(*this)[i] *= k;",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tRungeKutta operator*(const double& k) {",
            "\t\treturn (RungeKutta)(*this) *= k;",
            "\t}",
            "\tRungeKutta func() const;",
            "\tvector<RungeKutta> calc(double dt, int period) {",
            "\t\tvector<RungeKutta> Y;",
            "\t\tY.push_back(*this);",
            "\t\tfor(int i = 0; i < period; i++) {",
            "\t\t\tRungeKutta k1 = Y.back().func();",
            "\t\t\tRungeKutta k2 = (Y.back() + k1 * (dt / 2.0)).func();",
            "\t\t\tRungeKutta k3 = (Y.back() + k2 * (dt / 2.0)).func();",
            "\t\t\tRungeKutta k4 = (Y.back() + k3 * dt).func();",
            "\t\t\tY.push_back(Y.back() + (k1 + k2 * 2.0 + k3 * 2.0 + k4) * (dt / 6.0));",
            "\t\t}",
            "\t\treturn Y;",
            "\t}",
            "};",
            "RungeKutta RungeKutta::func() const {",
            "\tconst int n = this->size();",
            "\tRungeKutta res(n);",
            "\t// To do f(X) [0] : x, [1] : y, [2] : vx, [3] : vy",
            "\tres[0] = (*this)[2];",
            "\tres[1] = (*this)[3];",
            "\tres[2] = (*this)[3];",
            "\tres[3] = -(*this)[2];",
            "\treturn res;",
            "}",
            "int main(void) {",
            "\t// To do ",
            "\tconst double m = 1.0;",
            "\tconst double q = 1.0;",
            "\tconst double B = 1.0;",
            "\tconst double tau = 2.0 * M_PI * m / (q * B);",
            "\tconst int period = 64;",
            "\tconst double dt = tau / period;",
            "\t// To do ",
            "\tRungeKutta Y_0 = {-1.0, 0.0, 0.0, 1.0};",
            "\t// To do ",
            "\tvector<RungeKutta> Y = Y_0.calc(dt, period);",
            "\tfor(int i = 0; i <= period; i++) {",
            "\t\tcout << fixed << setprecision(15) << Y[i][0] << ' ' << Y[i][1] << '\n';",
            "\t}",
            "\treturn 0;",
            "}",
        ]
    },
    "RollingHash": {
        "prefix": "RollingHash",
        "body": [
            "struct RandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tinline ll operator()(ll lower, ll upper) {",
            "\t\tassert(lower <= upper);",
            "\t\tuniform_int_distribution<ll> dist(lower, upper);",
            "\t\treturn dist(mt);",
            "\t}",
            "} rng;",
            "struct RollingHash {",
            "\tusing ull = unsigned long long;",
            "\tRollingHash(const string &s, ll BASE = rng(1e8, 1e9)) {",
            "\t\tlen = (int)s.size();",
            "\t\tbase = BASE;",
            "\t\tpow.resize(len + 5);",
            "\t\tpow[0] = 1;",
            "\t\tfor(int i = 1; i < len + 5; ++i) {",
            "\t\t\tpow[i] = calc_mod(mul(pow[i - 1], base));",
            "\t\t}",
            "\t\thash.resize(len + 1);",
            "\t\tfor(int i = 0; i < len; ++i) {",
            "\t\t\thash[i + 1] = calc_mod(mul(hash[i], base) + s[i]);",
            "\t\t}",
            "\t}",
            "\tll get(int lower, int upper) const {",
            "\t\tassert(0 <= lower and lower <= upper and upper <= len);",
            "\t\treturn calc_mod(hash[upper] + POSITIVIZER - mul(hash[lower], pow[upper - lower]));",
            "\t}",
            "\tll get_hash(const string &t) const {",
            "\t\tll res = 0;",
            "\t\tfor(int i = 0; i < (int)t.size(); ++i) {",
            "\t\t\tres = calc_mod(mul(res, base) + t[i]);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tint find(const string &t, int lower = 0) const {",
            "\t\tll ha = get_hash(t);",
            "\t\tfor(int i = lower; i < len - (int)t.size() + 1; ++i) {",
            "\t\t\tif(ha == get(i, i + (int)t.size())) return i;",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "\tint LCP(const RollingHash &a, const RollingHash &b, int al, int bl) const {",
            "\t\tint ok = 0, ng = min(a.len - al, b.len - bl) + 1;",
            "\t\twhile(ok + 1 < ng) {",
            "\t\t\tint med = (ok + ng) / 2;",
            "\t\t\tif(a.get(al, med + al) == b.get(bl, med + bl)) {",
            "\t\t\t\tok = med;",
            "\t\t\t} else {",
            "\t\t\t\tng = med;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ok;",
            "\t}",
            "",
            "   private:",
            "\tconst ull MASK30 = (1ull << 30) - 1;",
            "\tconst ull MASK31 = (1ull << 31) - 1;",
            "\tconst ull MOD = (1ull << 61) - 1;",
            "\tconst ull POSITIVIZER = MOD * ((1ull << 3) - 1);",
            "\tint len;",
            "\tll base;",
            "\tvector<ull> pow;",
            "\tvector<ull> hash;",
            "\tinline ull mul(ull x, ull y) const {",
            "\t\tll xu = x >> 31;",
            "\t\tll xd = x & MASK31;",
            "\t\tll yu = y >> 31;",
            "\t\tll yd = y & MASK31;",
            "\t\tll middlebit = xd * yu + xu * yd;",
            "\t\treturn ((xu * yu) << 1) + xd * yd + ((middlebit & MASK30) << 31) + (middlebit >> 30);",
            "\t}",
            "\tinline ll calc_mod(ull val) const {",
            "\t\tval = (val & MOD) + (val >> 61);",
            "\t\tif(val > MOD) val -= MOD;",
            "\t\treturn val;",
            "\t}",
            "};",
        ]
    },
    "Z_algorithm": {
        "prefix": "Z_algorithm",
        "body": [
            "template <class T>",
            "vector<int> z_algorithm(const vector<T>& s) {",
            "\tint n = int(s.size());",
            "\tif(n == 0) return {};",
            "\tvector<int> z(n);",
            "\tz[0] = 0;",
            "\tfor(int i = 1, j = 0; i < n; ++i) {",
            "\t\tint& k = z[i];",
            "\t\tk = (j + z[j] <= i) ? 0 : min(j + z[j] - i, z[i - j]);",
            "\t\twhile(i + k < n and s[k] == s[i + k]) ++k;",
            "\t\tif(j + z[j] < i + z[i]) j = i;",
            "\t}",
            "\tz[0] = n;",
            "\treturn z;",
            "}",
            "vector<int> z_algorithm(const string& s) {",
            "\tint n = int(s.size());",
            "\tvector<int> s2(n);",
            "\tfor(int i = 0; i < n; ++i) {",
            "\t\ts2[i] = s[i];",
            "\t}",
            "\treturn z_algorithm(s2);",
            "}",
        ]
    },
    "RandomNumberGenerator": {
        "prefix": "RandomNumberGenerator",
        "body": [
            "struct RandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tinline ll operator()(const ll lower, const ll upper) {",
            "\t\treturn num(lower, upper);",
            "\t}",
            "\tinline ll num(ll lower, ll upper) {",
            "\t\tuniform_int_distribution<ll> dist(lower, upper);",
            "\t\treturn dist(mt);",
            "\t}",
            "\tinline vector<ll> vec(int n, ll lower, ll upper) {",
            "\t\tvector<ll> res(n);",
            "\t\tfor(int i = 0; i < n; ++i) res[i] = num(lower, upper);",
            "\t\treturn res;",
            "\t}",
            "\tinline vector<ll> perm(int n) {",
            "\t\tvector<ll> res(n);",
            "\t\tfor(int i = 0; i < n; ++i) res[i] = i + 1;",
            "\t\tfor(int i = n - 1; i > 0; --i) {",
            "\t\t\tswap(res[i], res[num(0, i)]);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "} rng;",
            "struct RealRandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRealRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tinline long double operator()(const long double lower, const long double upper) {",
            "\t\treturn num(lower, upper);",
            "\t}",
            "\tinline long double num(long double lower, long double upper) {",
            "\t\tuniform_real_distribution<long double> dist(lower, upper);",
            "\t\treturn dist(mt);",
            "\t}",
            "\tinline vector<long double> vec(int n, long double lower, long double upper) {",
            "\t\tvector<long double> res(n);",
            "\t\tfor(int i = 0; i < n; ++i) res[i] = num(lower, upper);",
            "\t\treturn res;",
            "\t}",
            "} rrng;",
        ]
    },
    "StaticModint": {
        "prefix": "StaticModint",
        "body": [
            "template <uint32_t m>",
            "struct StaticModint {",
            "\tusing mint = StaticModint;",
            "\tstatic constexpr uint32_t mod() {",
            "\t\treturn m;",
            "\t}",
            "\tstatic constexpr mint raw(uint32_t v) {",
            "\t\tmint a;",
            "\t\ta._v = v;",
            "\t\treturn a;",
            "\t}",
            "\tconstexpr StaticModint()",
            "\t\t: _v(0) {}",
            "\ttemplate <class T>",
            "\tconstexpr StaticModint(const T& v) {",
            "\t\tstatic_assert(is_integral_v<T>);",
            "\t\tif constexpr(is_signed_v<T>) {",
            "\t\t\tint64_t x = int64_t(v % int64_t(m));",
            "\t\t\tif(x < 0) x += m;",
            "\t\t\t_v = uint32_t(x);",
            "\t\t} else _v = uint32_t(v % m);",
            "\t}",
            "\tconstexpr uint32_t val() const {",
            "\t\treturn _v;",
            "\t}",
            "\tconstexpr mint& operator++() {",
            "\t\treturn *this += 1;",
            "\t}",
            "\tconstexpr mint& operator--() {",
            "\t\treturn *this -= 1;",
            "\t}",
            "\tconstexpr mint operator++(int) {",
            "\t\tmint res = *this;",
            "\t\t++*this;",
            "\t\treturn res;",
            "\t}",
            "\tconstexpr mint operator--(int) {",
            "\t\tmint res = *this;",
            "\t\t--*this;",
            "\t\treturn res;",
            "\t}",
            "\tconstexpr mint& operator+=(mint rhs) {",
            "\t\tif(_v >= m - rhs._v) _v -= m;",
            "\t\t_v += rhs._v;",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint& operator-=(mint rhs) {",
            "\t\tif(_v < rhs._v) _v += m;",
            "\t\t_v -= rhs._v;",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint& operator*=(mint rhs) {",
            "\t\treturn *this = *this * rhs;",
            "\t}",
            "\tconstexpr mint& operator/=(mint rhs) {",
            "\t\treturn *this *= rhs.inv();",
            "\t}",
            "\tconstexpr mint operator+() const {",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint operator-() const {",
            "\t\treturn mint{} - *this;",
            "\t}",
            "\tconstexpr mint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tif(n == 0) return 1;",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile(1) {",
            "\t\t\tif(n & 1) r *= x;",
            "\t\t\tn >>= 1;",
            "\t\t\tif(n == 0) return r;",
            "\t\t\tx *= x;",
            "\t\t}",
            "\t}",
            "\tconstexpr mint inv() const {",
            "\t\tif constexpr(prime) {",
            "\t\t\tassert(_v);",
            "\t\t\treturn pow(m - 2);",
            "\t\t} else {",
            "\t\t\tauto eg = inv_gcd(_v, m);",
            "\t\t\tassert(eg.first == 1);",
            "\t\t\treturn eg.second;",
            "\t\t}",
            "\t}",
            "\tfriend constexpr mint operator+(mint lhs, mint rhs) {",
            "\t\treturn lhs += rhs;",
            "\t}",
            "\tfriend constexpr mint operator-(mint lhs, mint rhs) {",
            "\t\treturn lhs -= rhs;",
            "\t}",
            "\tfriend constexpr mint operator*(mint lhs, mint rhs) {",
            "\t\treturn uint64_t(lhs._v) * rhs._v;",
            "\t}",
            "\tfriend constexpr mint operator/(mint lhs, mint rhs) {",
            "\t\treturn lhs /= rhs;",
            "\t}",
            "\tfriend constexpr bool operator==(mint lhs, mint rhs) {",
            "\t\treturn lhs._v == rhs._v;",
            "\t}",
            "\tfriend constexpr bool operator!=(mint lhs, mint rhs) {",
            "\t\treturn lhs._v != rhs._v;",
            "\t}",
            "",
            "   private:",
            "\tuint32_t _v = 0;",
            "\tstatic constexpr bool prime = []() -> bool {",
            "\t\tif(m == 1) return 0;",
            "\t\tif(m == 2 or m == 7 or m == 61) return 1;",
            "\t\tif(m % 2 == 0) return 0;",
            "\t\tuint32_t d = m - 1;",
            "\t\twhile(d % 2 == 0) d /= 2;",
            "\t\tfor(uint32_t a : {2, 7, 61}) {",
            "\t\t\tuint32_t t = d;",
            "\t\t\tmint y = mint(a).pow(t);",
            "\t\t\twhile(t != m - 1 && y != 1 && y != m - 1) {",
            "\t\t\t\ty *= y;",
            "\t\t\t\tt <<= 1;",
            "\t\t\t}",
            "\t\t\tif(y != m - 1 && t % 2 == 0) return 0;",
            "\t\t}",
            "\t\treturn 1;",
            "\t}();",
            "\tstatic constexpr pair<int32_t, int32_t> inv_gcd(int32_t a, int32_t b) {",
            "\t\tif(a == 0) return {b, 0};",
            "\t\tint32_t s = b, t = a, m0 = 0, m1 = 1;",
            "\t\twhile(t) {",
            "\t\t\tconst int32_t u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tswap(s, t);",
            "\t\t\tswap(m0, m1);",
            "\t\t}",
            "\t\tif(m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "};",
            "using mint = StaticModint<998244353>;",
            "istream& operator>>(istream& in, mint& x) {",
            "\tlong long a;",
            "\tin >> a;",
            "\tx = a;",
            "\treturn in;",
            "}",
            "ostream& operator<<(ostream& out, const mint& x) {",
            "\treturn out << x.val();",
            "}",
        ]
    },
    "DynamicModint": {
        "prefix": "DynamicModint",
        "body": [
            "struct barrett {",
            "\texplicit barrett(unsigned int m)",
            "\t\t: _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "\tinline unsigned int umod() const {",
            "\t\treturn _m;",
            "\t}",
            "\tinline unsigned int mul(unsigned int a, unsigned int b) const {",
            "\t\tunsigned long long z = a;",
            "\t\tz *= b;",
            "\t\tunsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "\t\tunsigned int v = (unsigned int)(z - x * _m);",
            "\t\tif(_m <= v) v += _m;",
            "\t\treturn v;",
            "\t}",
            "",
            "   private:",
            "\tunsigned int _m;",
            "\tunsigned long long im;",
            "};",
            "template <int id>",
            "struct DynamicModint {",
            "\tusing mint = DynamicModint;",
            "\tstatic int mod() {",
            "\t\treturn (int)bt.umod();",
            "\t}",
            "\tstatic void set_mod(int m) {",
            "\t\tassert(1 <= m);",
            "\t\tbt = barrett(m);",
            "\t}",
            "\tstatic mint raw(int v) {",
            "\t\tmint a;",
            "\t\ta._v = v;",
            "\t\treturn a;",
            "\t}",
            "\tDynamicModint()",
            "\t\t: _v(0) {}",
            "\ttemplate <class T>",
            "\tDynamicModint(const T& v) {",
            "\t\tstatic_assert(is_integral_v<T>);",
            "\t\tif(is_signed_v<T>) {",
            "\t\t\tlong long x = (long long)(v % (long long)(umod()));",
            "\t\t\tif(x < 0) x += umod();",
            "\t\t\t_v = (unsigned int)(x);",
            "\t\t} else _v = (unsigned int)(v % umod());",
            "\t}",
            "\tunsigned int val() const {",
            "\t\treturn _v;",
            "\t}",
            "\tmint& operator++() {",
            "\t\t_v++;",
            "\t\tif(_v == umod()) _v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator--() {",
            "\t\tif(_v == 0) _v = umod();",
            "\t\t_v--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint res = *this;",
            "\t\t++*this;",
            "\t\treturn res;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint res = *this;",
            "\t\t--*this;",
            "\t\treturn res;",
            "\t}",
            "\tmint& operator+=(const mint& rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif(_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator-=(const mint& rhs) {",
            "\t\t_v += mod() - rhs._v;",
            "\t\tif(_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator*=(const mint& rhs) {",
            "\t\t_v = bt.mul(_v, rhs._v);",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator/=(const mint& rhs) {",
            "\t\treturn *this *= rhs.inv();",
            "\t}",
            "\tmint operator+() const {",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator-() const {",
            "\t\treturn mint() - *this;",
            "\t}",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tif(n == 0) return 1;",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile(1) {",
            "\t\t\tif(n & 1) r *= x;",
            "\t\t\tn >>= 1;",
            "\t\t\tif(n == 0) return r;",
            "\t\t\tx *= x;",
            "\t\t}",
            "\t}",
            "\tmint inv() const {",
            "\t\tauto eg = inv_gcd(_v, mod());",
            "\t\tassert(eg.first == 1);",
            "\t\treturn eg.second;",
            "\t}",
            "\tfriend mint operator+(const mint& lhs, const mint& rhs) {",
            "\t\treturn mint(lhs) += rhs;",
            "\t}",
            "\tfriend mint operator-(const mint& lhs, const mint& rhs) {",
            "\t\treturn mint(lhs) -= rhs;",
            "\t}",
            "\tfriend mint operator*(const mint& lhs, const mint& rhs) {",
            "\t\treturn mint(lhs) *= rhs;",
            "\t}",
            "\tfriend mint operator/(const mint& lhs, const mint& rhs) {",
            "\t\treturn mint(lhs) /= rhs;",
            "\t}",
            "\tfriend bool operator==(const mint& lhs, const mint& rhs) {",
            "\t\treturn lhs._v == rhs._v;",
            "\t}",
            "\tfriend bool operator!=(const mint& lhs, const mint& rhs) {",
            "\t\treturn lhs._v != rhs._v;",
            "\t}",
            "",
            "   private:",
            "\tunsigned int _v = 0;",
            "\tstatic barrett bt;",
            "\tinline static unsigned int umod() {",
            "\t\treturn bt.umod();",
            "\t}",
            "\tinline static pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\tif(a == 0) return {b, 0};",
            "\t\tlong long s = b, t = a, m0 = 0, m1 = 1;",
            "\t\twhile(t) {",
            "\t\t\tconst long long u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tswap(s, t);",
            "\t\t\tswap(m0, m1);",
            "\t\t}",
            "\t\tif(m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "};",
            "template <int id>",
            "barrett DynamicModint<id>::bt(998244353);",
            "using mint = DynamicModint<-1>;",
            "istream& operator>>(istream& in, mint& x) {",
            "\tlong long a;",
            "\tin >> a;",
            "\tx = a;",
            "\treturn in;",
            "}",
            "ostream& operator<<(ostream& out, const mint& x) {",
            "\treturn out << x.val();",
            "}",
        ]
    },
    "TemplateAtCoder": {
        "prefix": "TemplateAtCoder",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "using namespace std;",
            "using namespace atcoder;",
            "using ll = long long;",
            "using P = pair<ll, ll>;",
            "using mint = modint998244353;",
            "#define rep(i, a, b) for(ll i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(ll i = a; i >= b; --i)",
            "constexpr ll inf = 4e18;",
            "int main(void) {",
            "\tcin.tie(0);",
            "\tios::sync_with_stdio(0);",
            "\t",
            "}",
        ]
    },
    "TemplateCodeforces": {
        "prefix": "TemplateCodeforces",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "using P = pair<ll, ll>;",
            "#define rep(i, a, b) for(ll i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(ll i = a; i >= b; --i)",
            "constexpr ll inf = 4e18;",
            "int main(void) {",
            "\tcin.tie(0);",
            "\tios::sync_with_stdio(0);",
            "\t",
            "}",
        ]
    },
    "TemplateTopcoder": {
        "prefix": "TemplateTopcoder",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "typedef pair<ll, ll> P;",
            "#define rep(i, a, b) for(ll i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(ll i = a; i >= b; --i)",
            "constexpr ll inf = 4e18;",
            "constexpr ll MOD = 1e9 + 7;",
            "class Topcoder {",
            "   public:",
            "\tint solution(int n, int k) {",
            "",
            "\t}",
            "};",
            "/*",
            "int main(void){",
            "\tcin.tie(0);",
            "\tios::sync_with_stdio(0);",
            "\tll n,k;",
            "\tcin>>n>>k;",
            "\tTopCoder ans;",
            "\tcout<<ans.solution(n,k)<<endl;",
            "}",
            "*/",
        ]
    },
}
