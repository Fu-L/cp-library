---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: src/template/template.hpp
    title: template
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: src/graph/biconnected_components.hpp
    title: BiconnectedComponents
  - icon: ':heavy_check_mark:'
    path: src/graph/bipartite.hpp
    title: bipartite
  - icon: ':heavy_check_mark:'
    path: src/graph/compressed_sparse_row.hpp
    title: CompressedSparseRow
  - icon: ':heavy_check_mark:'
    path: src/graph/cycle_detection.hpp
    title: cycle_detection
  - icon: ':heavy_check_mark:'
    path: src/graph/dijkstra.hpp
    title: dijkstra
  - icon: ':heavy_check_mark:'
    path: src/graph/kruskal.hpp
    title: kruskal
  - icon: ':heavy_check_mark:'
    path: src/graph/low_link.hpp
    title: LowLink
  - icon: ':heavy_check_mark:'
    path: src/graph/strongly_connected_components.hpp
    title: strongly_connected_components
  - icon: ':heavy_check_mark:'
    path: src/graph/topological_sort.hpp
    title: topological_sort
  - icon: ':heavy_check_mark:'
    path: src/graph/two_edge_connected_components.hpp
    title: TwoEdgeConnectedComponents
  - icon: ':heavy_check_mark:'
    path: src/graph/two_sat.hpp
    title: TwoSAT
  - icon: ':heavy_check_mark:'
    path: src/tree/cartesian_tree.hpp
    title: cartesian_tree
  - icon: ':heavy_check_mark:'
    path: src/tree/centroid.hpp
    title: centroid
  - icon: ':heavy_check_mark:'
    path: src/tree/centroid_decomposition.hpp
    title: centroid_decomposition
  - icon: ':heavy_check_mark:'
    path: src/tree/heavy_light_decomposition.hpp
    title: HeavyLightDecomposition
  - icon: ':heavy_check_mark:'
    path: src/tree/lowest_common_ancestor.hpp
    title: LowestCommonAncestor
  - icon: ':heavy_check_mark:'
    path: src/tree/rerooting.hpp
    title: rerooting
  - icon: ':heavy_check_mark:'
    path: src/tree/tree_diameter.hpp
    title: tree_diameter
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/articulation_points.test.cpp
    title: verify/aizu_online_judge/grl/articulation_points.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/bridges.test.cpp
    title: verify/aizu_online_judge/grl/bridges.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/cycle_detection_for_a_directed_graph.test.cpp
    title: verify/aizu_online_judge/grl/cycle_detection_for_a_directed_graph.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/diameter_of_a_tree.test.cpp
    title: verify/aizu_online_judge/grl/diameter_of_a_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/height_of_a_tree.test.cpp
    title: verify/aizu_online_judge/grl/height_of_a_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/lowest_common_ancestor.test.cpp
    title: verify/aizu_online_judge/grl/lowest_common_ancestor.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/minimum_spanning_tree.test.cpp
    title: verify/aizu_online_judge/grl/minimum_spanning_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/range_query_on_a_tree.test.cpp
    title: verify/aizu_online_judge/grl/range_query_on_a_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/range_query_on_a_tree_2.test.cpp
    title: verify/aizu_online_judge/grl/range_query_on_a_tree_2.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/single_source_shortest_path.test.cpp
    title: verify/aizu_online_judge/grl/single_source_shortest_path.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/aizu_online_judge/grl/strongly_connected_components.test.cpp
    title: verify/aizu_online_judge/grl/strongly_connected_components.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/vertex_add_path_sum.test.cpp
    title: verify/library_checker/data_structure/vertex_add_path_sum.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/vertex_add_subtree_sum.test.cpp
    title: verify/library_checker/data_structure/vertex_add_subtree_sum.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/data_structure/vertex_set_path_composite.test.cpp
    title: verify/library_checker/data_structure/vertex_set_path_composite.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/biconnected_components.test.cpp
    title: verify/library_checker/graph/biconnected_components.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/cycle_detection_directed.test.cpp
    title: verify/library_checker/graph/cycle_detection_directed.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/cycle_detection_undirected.test.cpp
    title: verify/library_checker/graph/cycle_detection_undirected.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/minimum_spanning_tree.test.cpp
    title: verify/library_checker/graph/minimum_spanning_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/shortest_path.test.cpp
    title: verify/library_checker/graph/shortest_path.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/strongly_connected_components.test.cpp
    title: verify/library_checker/graph/strongly_connected_components.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/graph/two_edge_connected_components.test.cpp
    title: verify/library_checker/graph/two_edge_connected_components.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/math/2_sat.test.cpp
    title: verify/library_checker/math/2_sat.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/cartesian_tree.test.cpp
    title: verify/library_checker/tree/cartesian_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/frequency_table_of_tree_distance.test.cpp
    title: verify/library_checker/tree/frequency_table_of_tree_distance.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/jump_on_tree.test.cpp
    title: verify/library_checker/tree/jump_on_tree.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/lowest_common_ancestor.test.cpp
    title: verify/library_checker/tree/lowest_common_ancestor.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/library_checker/tree/tree_diameter.test.cpp
    title: verify/library_checker/tree/tree_diameter.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/unit_test/graph/bipartite.test.cpp
    title: verify/unit_test/graph/bipartite.test.cpp
  - icon: ':heavy_check_mark:'
    path: verify/unit_test/tree/centroid.test.cpp
    title: verify/unit_test/tree/centroid.test.cpp
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 2 \"src/template/template.hpp\"\n#include <bits/stdc++.h>\n\
    using namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n#define\
    \ rep(i, a, b) for(ll i = a; i < b; ++i)\n#define rrep(i, a, b) for(ll i = a;\
    \ i >= b; --i)\nconstexpr ll inf = 4e18;\nstruct SetupIO {\n    SetupIO() {\n\
    \        ios::sync_with_stdio(0);\n        cin.tie(0);\n        cout << fixed\
    \ << setprecision(30);\n    }\n} setup_io;\n#line 3 \"src/graph/graph_template.hpp\"\
    \ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    int\
    \ idx;\n    Edge()\n        : from(-1), to(-1), cost(-1), idx(-1) {}\n    Edge(int\
    \ from, int to, const T& cost = 1, int idx = -1)\n        : from(from), to(to),\
    \ cost(cost), idx(idx) {}\n    operator int() const {\n        return to;\n  \
    \  }\n};\ntemplate <typename T>\nstruct Graph {\n    Graph(int N)\n        : n(N),\
    \ es(0), g(N) {}\n    int size() const {\n        return n;\n    }\n    int edge_size()\
    \ const {\n        return es;\n    }\n    void add_edge(int from, int to, const\
    \ T& cost = 1) {\n        assert(0 <= from and from < n);\n        assert(0 <=\
    \ to and to < n);\n        g[from].emplace_back(from, to, cost, es);\n       \
    \ g[to].emplace_back(to, from, cost, es++);\n    }\n    void add_directed_edge(int\
    \ from, int to, const T& cost = 1) {\n        assert(0 <= from and from < n);\n\
    \        assert(0 <= to and to < n);\n        g[from].emplace_back(from, to, cost,\
    \ es++);\n    }\n    inline vector<Edge<T>>& operator[](const int& k) {\n    \
    \    assert(0 <= k and k < n);\n        return g[k];\n    }\n    inline const\
    \ vector<Edge<T>>& operator[](const int& k) const {\n        assert(0 <= k and\
    \ k < n);\n        return g[k];\n    }\n\n   private:\n    int n, es;\n    vector<vector<Edge<T>>>\
    \ g;\n};\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;\n"
  code: "#pragma once\n#include \"../template/template.hpp\"\ntemplate <typename T>\n\
    struct Edge {\n    int from, to;\n    T cost;\n    int idx;\n    Edge()\n    \
    \    : from(-1), to(-1), cost(-1), idx(-1) {}\n    Edge(int from, int to, const\
    \ T& cost = 1, int idx = -1)\n        : from(from), to(to), cost(cost), idx(idx)\
    \ {}\n    operator int() const {\n        return to;\n    }\n};\ntemplate <typename\
    \ T>\nstruct Graph {\n    Graph(int N)\n        : n(N), es(0), g(N) {}\n    int\
    \ size() const {\n        return n;\n    }\n    int edge_size() const {\n    \
    \    return es;\n    }\n    void add_edge(int from, int to, const T& cost = 1)\
    \ {\n        assert(0 <= from and from < n);\n        assert(0 <= to and to <\
    \ n);\n        g[from].emplace_back(from, to, cost, es);\n        g[to].emplace_back(to,\
    \ from, cost, es++);\n    }\n    void add_directed_edge(int from, int to, const\
    \ T& cost = 1) {\n        assert(0 <= from and from < n);\n        assert(0 <=\
    \ to and to < n);\n        g[from].emplace_back(from, to, cost, es++);\n    }\n\
    \    inline vector<Edge<T>>& operator[](const int& k) {\n        assert(0 <= k\
    \ and k < n);\n        return g[k];\n    }\n    inline const vector<Edge<T>>&\
    \ operator[](const int& k) const {\n        assert(0 <= k and k < n);\n      \
    \  return g[k];\n    }\n\n   private:\n    int n, es;\n    vector<vector<Edge<T>>>\
    \ g;\n};\ntemplate <typename T>\nusing Edges = vector<Edge<T>>;"
  dependsOn:
  - src/template/template.hpp
  isVerificationFile: false
  path: src/graph/graph_template.hpp
  requiredBy:
  - src/graph/dijkstra.hpp
  - src/graph/two_edge_connected_components.hpp
  - src/graph/compressed_sparse_row.hpp
  - src/graph/two_sat.hpp
  - src/graph/biconnected_components.hpp
  - src/graph/cycle_detection.hpp
  - src/graph/low_link.hpp
  - src/graph/topological_sort.hpp
  - src/graph/kruskal.hpp
  - src/graph/strongly_connected_components.hpp
  - src/graph/bipartite.hpp
  - src/tree/heavy_light_decomposition.hpp
  - src/tree/centroid_decomposition.hpp
  - src/tree/cartesian_tree.hpp
  - src/tree/lowest_common_ancestor.hpp
  - src/tree/tree_diameter.hpp
  - src/tree/centroid.hpp
  - src/tree/rerooting.hpp
  timestamp: '2024-06-04 23:34:08+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - verify/library_checker/data_structure/vertex_set_path_composite.test.cpp
  - verify/library_checker/data_structure/vertex_add_subtree_sum.test.cpp
  - verify/library_checker/data_structure/vertex_add_path_sum.test.cpp
  - verify/library_checker/graph/minimum_spanning_tree.test.cpp
  - verify/library_checker/graph/two_edge_connected_components.test.cpp
  - verify/library_checker/graph/cycle_detection_directed.test.cpp
  - verify/library_checker/graph/cycle_detection_undirected.test.cpp
  - verify/library_checker/graph/strongly_connected_components.test.cpp
  - verify/library_checker/graph/biconnected_components.test.cpp
  - verify/library_checker/graph/shortest_path.test.cpp
  - verify/library_checker/math/2_sat.test.cpp
  - verify/library_checker/tree/frequency_table_of_tree_distance.test.cpp
  - verify/library_checker/tree/jump_on_tree.test.cpp
  - verify/library_checker/tree/cartesian_tree.test.cpp
  - verify/library_checker/tree/lowest_common_ancestor.test.cpp
  - verify/library_checker/tree/tree_diameter.test.cpp
  - verify/aizu_online_judge/grl/range_query_on_a_tree.test.cpp
  - verify/aizu_online_judge/grl/minimum_spanning_tree.test.cpp
  - verify/aizu_online_judge/grl/diameter_of_a_tree.test.cpp
  - verify/aizu_online_judge/grl/strongly_connected_components.test.cpp
  - verify/aizu_online_judge/grl/cycle_detection_for_a_directed_graph.test.cpp
  - verify/aizu_online_judge/grl/single_source_shortest_path.test.cpp
  - verify/aizu_online_judge/grl/bridges.test.cpp
  - verify/aizu_online_judge/grl/lowest_common_ancestor.test.cpp
  - verify/aizu_online_judge/grl/height_of_a_tree.test.cpp
  - verify/aizu_online_judge/grl/articulation_points.test.cpp
  - verify/aizu_online_judge/grl/range_query_on_a_tree_2.test.cpp
  - verify/unit_test/graph/bipartite.test.cpp
  - verify/unit_test/tree/centroid.test.cpp
documentation_of: src/graph/graph_template.hpp
layout: document
title: Graph
---

# Edge

グラフの辺の情報を保持する構造体です．

グラフの辺の重みを `T` とします．<br>
重みなしグラフを扱う場合も，重み $1$ の重み付きグラフと考えてください．

## コンストラクタ

```cpp
(1) Edge<T = int> e()
(2) Edge<T = int> e(int from, int to, T cost = 1, int idx = -1)
```

- (1): 有向辺 `e` を作ります．<br>
`from` などのメンバ変数は $-1$ で初期化されます．
- (2): `from` を始点 `to` を終点とする 重み `cost` の有向辺 `e` を作ります．<br>
ラベル `idx` をつけることもできます．

**計算量**

- $O(1)$

## メンバ変数

```cpp
(1) int e.from
(2) int e.to
(3) T e.cost
(4) int e.idx
```

- (1): 有向辺 `e` の始点を返します．
- (2): 有向辺 `e` の終点を返します．
- (3): `e` の重みを返します．
- (4): `e` のラベルを返します．

## operator int()

```cpp
int(e)
```

有向辺 `e` を `int` 型でキャストすると， `e.to` を返します．

**計算量**

- $O(1)$

## Tips

辺集合 `vector<Edge<T>>` を扱いたいときは， `Edges` というエイリアスが用意されています．

# Graph

グラフを扱う構造体です．

グラフの辺の重みを `T` とします．<br>
重みなしグラフを扱う場合も，重み $1$ の重み付きグラフと考えてください．

## コンストラクタ

```cpp
Graph<T = int> g(int n)
```

- $n$ 頂点 $0$ 辺のグラフを作成します．

**計算量**

- $O(n)$

## size

```cpp
int g.size()
```

グラフ `g` の頂点数を返します．

**計算量**

- $O(1)$

## edge_size

```cpp
int g.edge_size()
```

グラフ `g` の辺数を返します．

**計算量**

- $O(1)$

## add_edge

```cpp
void g.add_edge(int from, int to, T cost = 1)
```

頂点 `from` と頂点 `to` を結ぶ重み `cost` の無向辺を追加します．

辺のラベルはグラフに追加した順番と一致します．<br>
`from → to` の辺と `to → from` の辺のラベルは一致します．

また，メンバ変数の辺数は $1$ 本だけ増えます．

**制約**

- $0 \leq \mathrm{from} < n$
- $0 \leq \mathrm{to} < n$

**計算量**

- 償却 $O(1)$

## add_directed_edge

```cpp
void g.add_directed_edge(int from, int to, T cost = 1)
```

頂点 `from` から頂点 `to` への重み `cost` の有向辺を追加します．

辺のラベルはグラフに追加した順番と一致します．

また，メンバ変数の辺数は $1$ 本だけ増えます．

**制約**

- $0 \leq \mathrm{from} < n$
- $0 \leq \mathrm{to} < n$

**計算量**

- 償却 $O(1)$

## operator []

```cpp
vector<Edge<T>> g[int i]
```

頂点 $i$ に隣接する頂点集合を返します．

**制約**

- $0 \leq i < n$

**計算量**

- $O(1)$