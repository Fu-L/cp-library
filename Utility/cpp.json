{
    // Template
    "TemplateAtCoder": {
        "prefix": "TemplateAtCoder",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "using namespace std;",
            "using namespace atcoder;",
            "using ll = long long;",
            "using P = pair<ll, ll>;",
            "using mint = modint998244353;",
            "#define rep(i, a, b) for(ll i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(ll i = a; i >= b; --i)",
            "constexpr ll inf = 4e18;",
            "int main(void) {",
            "\tcin.tie(0);",
            "\tios::sync_with_stdio(0);",
            "\t",
            "}"
        ]
    },
    "TemplateCodeforces": {
        "prefix": "TemplateCodeforces",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "using P = pair<ll, ll>;",
            "#define rep(i, a, b) for(ll i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(ll i = a; i >= b; --i)",
            "constexpr ll inf = 4e18;",
            "int main(void) {",
            "\tcin.tie(0);",
            "\tios::sync_with_stdio(0);",
            "\t",
            "}"
        ]
    },
    "TemplateTopcoder": {
        "prefix": "TemplateTopcoder",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using ll = long long;",
            "using P = pair<int, int>;",
            "#define rep(i, a, b) for(int i = a; i < b; ++i)",
            "#define rrep(i, a, b) for(int i = a; i >= b; --i)",
            "constexpr int inf = 1e9;",
            "constexpr int mod = 1000000007;",
            "class Topcoder {",
            "public:",
            "\tint solution(int n, int k) {",
            "\t\t",
            "\t}",
            "};"
        ]
    },
    "RandomNumberGenerator": {
        "prefix": "RandomNumberGenerator",
        "body": [
            "struct RandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tinline ll operator()(const ll l, const ll r) {",
            "\t\tuniform_int_distribution<ll> dist(l, r);",
            "\t\treturn dist(mt);",
            "\t}",
            "} rng;"
        ]
    },
    "RealRandomNumberGenerator": {
        "prefix": "RealRandomNumberGenerator",
        "body": [
            "struct RealRandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRealRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tinline long double operator()(const long double l, const long double r) {",
            "\t\tuniform_real_distribution<long double> dist(l, r);",
            "\t\treturn dist(mt);",
            "\t}",
            "} rrng;"
        ]
    },
    "StaticModint": {
        "prefix": "StaticModint",
        "body": [
            "constexpr int mod = 998244353;",
            "struct mint {",
            "\tll x;",
            "\tmint(ll x = 0)",
            "\t\t: x((x % mod + mod) % mod) {}",
            "\tint val() const {",
            "\t\treturn x;",
            "\t}",
            "\tmint operator+() const {",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator-() const {",
            "\t\treturn mint() - *this;",
            "\t}",
            "\tmint& operator++() {",
            "\t\tx++;",
            "\t\tif(x == mod) x = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator--() {",
            "\t\tif(x == 0) x = mod;",
            "\t\tx--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator+=(const mint& a) {",
            "\t\tif((x += a.x) >= mod) x -= mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator-=(const mint& a) {",
            "\t\tif((x += mod - a.x) >= mod) x -= mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator*=(const mint& a) {",
            "\t\t(x *= a.x) %= mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint pow(ll t) const {",
            "\t\tmint x = *this, a = 1;",
            "\t\twhile(t) {",
            "\t\t\tif(t & 1) a *= x;",
            "\t\t\tx *= x;",
            "\t\t\tt >>= 1;",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "\tmint inv() const {",
            "\t\treturn pow(mod - 2);",
            "\t}",
            "\tmint& operator/=(const mint a) {",
            "\t\treturn *this *= a.inv();",
            "\t}",
            "\tfriend mint operator+(const mint& a, const mint& b) {",
            "\t\treturn mint(a) += b;",
            "\t}",
            "\tfriend mint operator-(const mint& a, const mint& b) {",
            "\t\treturn mint(a) -= b;",
            "\t}",
            "\tfriend mint operator*(const mint& a, const mint& b) {",
            "\t\treturn mint(a) *= b;",
            "\t}",
            "\tfriend mint operator/(const mint& a, const mint& b) {",
            "\t\treturn mint(a) /= b;",
            "\t}",
            "\tfriend bool operator==(const mint& a, const mint& b) {",
            "\t\treturn a.x == b.x;",
            "\t}",
            "\tfriend bool operator!=(const mint& a, const mint& b) {",
            "\t\treturn a.x != b.x;",
            "\t}",
            "};"
        ]
    },
    // DataStructure
    "RotateVector": {
        "prefix": "RotateVector",
        "body": [
            "template <typename T>",
            "vector<vector<T>> rotate(vector<vector<T>> vec) {",
            "\tint n = vec.size(), m = vec[0].size();",
            "\tvector<vector<T>> res(m, vector<T>(n));",
            "\trep(i, 0, n) {",
            "\t\trep(j, 0, m) {",
            "\t\t\tres[j][n - 1 - i] = vec[i][j];",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "DisjointSetUnion": {
        "prefix": "DisjointSetUnion",
        "body": [
            "struct dsu {",
            "\tint n;",
            "\tvector<int> data;",
            "\tdsu(int N)",
            "\t\t: n(N), data(N, -1) {}",
            "\tint merge(int a, int b) {",
            "\t\tassert(0 <= a && a < n);",
            "\t\tassert(0 <= b && b < n);",
            "\t\tint x = leader(a), y = leader(b);",
            "\t\tif(x == y) return x;",
            "\t\tif(-data[x] < -data[y]) swap(x, y);",
            "\t\tdata[x] += data[y];",
            "\t\tdata[y] = x;",
            "\t\treturn x;",
            "\t}",
            "\tbool same(int a, int b) {",
            "\t\tassert(0 <= a && a < n);",
            "\t\tassert(0 <= b && b < n);",
            "\t\treturn leader(a) == leader(b);",
            "\t}",
            "\tint leader(int a) {",
            "\t\tassert(0 <= a && a < n);",
            "\t\tif(data[a] < 0) return a;",
            "\t\treturn data[a] = leader(data[a]);",
            "\t}",
            "\tint size(int a) {",
            "\t\tassert(0 <= a && a < n);",
            "\t\treturn -data[leader(a)];",
            "\t}",
            "\tvector<vector<int>> groups() {",
            "\t\tvector<int> leader_buf(n), group_size(n);",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tleader_buf[i] = leader(i);",
            "\t\t\tgroup_size[leader_buf[i]]++;",
            "\t\t}",
            "\t\tvector<vector<int>> result(n);",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tresult[i].reserve(group_size[i]);",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tresult[leader_buf[i]].push_back(i);",
            "\t\t}",
            "\t\tresult.erase(remove_if(result.begin(), result.end(), [&](const vector<int>& v) { return v.empty(); }), result.end());",
            "\t\treturn result;",
            "\t}",
            "};"
        ]
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "template <typename T>",
            "struct SparseTable {",
            "\tvector<vector<T>> st;",
            "\tSparseTable(vector<T> &a) {",
            "\t\tint n = a.size();",
            "\t\tint LOG = 32 - __builtin_clz(n);",
            "\t\tst = vector<vector<T>>(LOG, vector<T>(n));",
            "\t\trep(i, 0, n) {",
            "\t\t\tst[0][i] = a[i];",
            "\t\t}",
            "\t\trep(i, 0, LOG - 1) {",
            "\t\t\trep(j, 0, n - (1 << i)) {",
            "\t\t\t\tst[i + 1][j] = min(st[i][j], st[i][j + (1 << i)]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tT query(int l, int r) {",
            "\t\tint d = 31 - __builtin_clz(r - l);",
            "\t\treturn min(st[d][l], st[d][r - (1 << d)]);",
            "\t}",
            "};"
        ]
    },
    "SparseTable2D": {
        "prefix": "SparseTable2D",
        "body": [
            "template <typename T>",
            "struct SparseTable2D {",
            "\tvector<vector<vector<vector<T>>>> table;",
            "\tvector<int> LOG;",
            "\tT const e = -inf;",
            "\tT comp(T a, T b) {",
            "\t\treturn max(a, b);",
            "\t};",
            "\tSparseTable2D(vector<vector<T>> &v) {",
            "\t\tint h = v.size();",
            "\t\tint w = v[0].size();",
            "\t\tLOG = vector<int>(max(h, w) + 1);",
            "\t\trep(i, 2, max(h, w) + 1) LOG[i] = LOG[i / 2] + 1;",
            "\t\ttable = vector<vector<vector<vector<T>>>>(LOG[h] + 1, vector<vector<vector<T>>>(LOG[w] + 1, vector<vector<T>>(h, vector<T>(w, e))));",
            "\t\trep(i, 0, h) rep(j, 0, w) table[0][0][i][j] = v[i][j];",
            "\t\trep(i, 0, LOG[h] + 1) rep(j, 0, LOG[w] + 1) rep(x, 0, h) rep(y, 0, w) {",
            "\t\t\tif(i < LOG[h]) table[i + 1][j][x][y] = comp(table[i][j][x][y], (x + (1 << i) < h) ? table[i][j][x + (1 << i)][y] : e);",
            "\t\t\tif(j < LOG[w]) table[i][j + 1][x][y] = comp(table[i][j][x][y], (y + (1 << j) < w) ? table[i][j][x][y + (1 << j)] : e);",
            "\t\t}",
            "\t}",
            "\tT query(int lx, int rx, int ly, int ry) {",
            "\t\tint kx = LOG[rx - lx];",
            "\t\tint ky = LOG[ry - ly];",
            "\t\treturn comp(comp(table[kx][ky][lx][ly], table[kx][ky][rx - (1 << kx)][ly]), comp(table[kx][ky][lx][ry - (1 << ky)], table[kx][ky][rx - (1 << kx)][ry - (1 << ky)]));",
            "\t}",
            "};"
        ]
    },
    "FenwickTree": {
        "prefix": "FenwickTree",
        "body": [
            "template <typename T>",
            "struct fenwick_tree {",
            "\tint n;",
            "\tvector<T> data;",
            "\tfenwick_tree(int N)",
            "\t\t: n(N), data(N) {}",
            "\tvoid add(int p, T x) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp++;",
            "\t\twhile(p <= n) {",
            "\t\t\tdata[p - 1] += x;",
            "\t\t\tp += p & -p;",
            "\t\t}",
            "\t}",
            "\tT sum(int r) {",
            "\t\tT s = 0;",
            "\t\twhile(r > 0) {",
            "\t\t\ts += data[r - 1];",
            "\t\t\tr -= r & -r;",
            "\t\t}",
            "\t\treturn s;",
            "\t}",
            "\tT sum(int l, int r) {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\treturn sum(r) - sum(l);",
            "\t}",
            "\tT operator[](int x) const {",
            "\t\tassert(0 <= x && x < n);",
            "\t\treturn sum(x, x + 1);",
            "\t}",
            "};"
        ]
    },
    "RangeMaximumQuery_RangeAddQuery": {
        "prefix": "RangeMaximumQuery_RangeAddQuery",
        "body": [
            "using S = ll;",
            "using F = ll;",
            "const S INF = 8e18;",
            "S op(S a, S b) {",
            "\treturn max(a, b);",
            "}",
            "S e() {",
            "\treturn -INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn f + x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}"
        ]
    },
    "RangeMaximumQuery_RangeUpdateQuery": {
        "prefix": "RangeMaximumQuery_RangeUpdateQuery",
        "body": [
            "using S = ll;",
            "using F = ll;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn max(a, b);",
            "}",
            "S e() {",
            "\treturn -INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn (f == ID ? x : f);",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}"
        ]
    },
    "RangeMinimumQuery_RangeAddQuery": {
        "prefix": "RangeMinimumQuery_RangeAddQuery",
        "body": [
            "using S = ll;",
            "using F = ll;",
            "const S INF = 8e18;",
            "S op(S a, S b) {",
            "\treturn min(a, b);",
            "}",
            "S e() {",
            "\treturn INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn f + x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}"
        ]
    },
    "RangeMinimumQuery_RangeUpdateQuery": {
        "prefix": "RangeMinimumQuery_RangeUpdateQuery",
        "body": [
            "using S = ll;",
            "using F = ll;",
            "const S INF = 8e18;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn min(a, b);",
            "}",
            "S e() {",
            "\treturn INF;",
            "}",
            "S mapping(F f, S x) {",
            "\treturn (f == ID ? x : f);",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}"
        ]
    },
    "RangeSumQuery_RangeAddQuery": {
        "prefix": "RangeSumQuery_RangeAddQuery",
        "body": [
            "struct S {",
            "\tll value;",
            "\tll size;",
            "};",
            "using F = ll;",
            "S op(S a, S b) {",
            "\treturn {a.value + b.value, a.size + b.size};",
            "}",
            "S e() {",
            "\treturn {0, 0};",
            "}",
            "S mapping(F f, S x) {",
            "\treturn {x.value + f * x.size, x.size};",
            "}",
            "F composition(F f, F g) {",
            "\treturn f + g;",
            "}",
            "F id() {",
            "\treturn 0;",
            "}"
        ]
    },
    "RangeSumQuery_RangeUpdateQuery": {
        "prefix": "RangeSumQuery_RangeUpdateQuery",
        "body": [
            "struct S {",
            "\tll value;",
            "\tll size;",
            "};",
            "using F = ll;",
            "const F ID = 8e18;",
            "S op(S a, S b) {",
            "\treturn {a.value + b.value, a.size + b.size};",
            "}",
            "S e() {",
            "\treturn {0, 0};",
            "}",
            "S mapping(F f, S x) {",
            "\tif(f != ID) x.value = f * x.size;",
            "\treturn x;",
            "}",
            "F composition(F f, F g) {",
            "\treturn (f == ID ? g : f);",
            "}",
            "F id() {",
            "\treturn ID;",
            "}"
        ]
    },
    "ConvexHullTrick": {
        "prefix": "ConvexHullTrick",
        "body": [
            "template <typename T>",
            "struct CHT {",
            "\tdeque<pair<T, T>> deq;",
            "\tT calc(pair<T, T> p, T x) {",
            "\t\treturn p.first * x + p.second;",
            "\t}",
            "\tll check(pair<T, T> A, pair<T, T> B, pair<T, T> C) {",
            "\t\treturn ((A.second - C.second) * (B.first - A.first) <= (A.second - B.second) * (C.first - A.first));",
            "\t}",
            "\tvoid add(T a, T b) {",
            "\t\tdeq.push_back({a, b});",
            "\t\tll v;",
            "\t\twhile((v = deq.size()) >= 3 && check(deq[v - 3], deq[v - 2], deq[v - 1])) {",
            "\t\t\tdeq[v - 2] = deq[v - 1];",
            "\t\t\tdeq.pop_back();",
            "\t\t}",
            "\t}",
            "\tT query(T x) {",
            "\t\tll l = -1, r = deq.size() - 1;",
            "\t\twhile(r - l > 1) {",
            "\t\t\tll m = (l + r) / 2;",
            "\t\t\tif(calc(deq[m], x) >= calc(deq[m + 1], x)) {",
            "\t\t\t\tl = m;",
            "\t\t\t} else {",
            "\t\t\t\tr = m;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn calc(deq[r], x);",
            "\t}",
            "};"
        ]
    },
    "Tree": {
        "prefix": "Tree",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "#include <ext/pb_ds/tag_and_trait.hpp>",
            "using namespace __gnu_pbds;",
            "using Tree = tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>; // set",
            "// using Tree = tree<ll,null_type,less_equal<ll>,rb_tree_tag,tree_order_statistics_node_update>; // multiset"
        ]
    },
    // Graph
    "TreeDiameter": {
        "prefix": "TreeDiameter",
        "body": [
            "struct TreeDiameter {",
            "\tint n;",
            "\tvector<vector<int>> to;",
            "\tvector<vector<ll>> cost;",
            "\tTreeDiameter(int n)",
            "\t\t: n(n), to(n), cost(n) {}",
            "\tvoid add_edge(int u, int v, ll c = 1) {",
            "\t\tto[u].push_back(v);",
            "\t\tto[v].push_back(u);",
            "\t\tcost[u].push_back(c);",
            "\t\tcost[v].push_back(c);",
            "\t}",
            "\tpair<ll, vector<int>> diameter() {",
            "\t\tvector<ll> dist(n);",
            "\t\tvector<int> par(n);",
            "\t\tauto dfs = [&](auto& dfs, int v, int p, ll dep) -> void {",
            "\t\t\tdist[v] = dep;",
            "\t\t\tpar[v] = p;",
            "\t\t\trep(i, 0, (int)to[v].size()) {",
            "\t\t\t\tif(to[v][i] == p) continue;",
            "\t\t\t\tdfs(dfs, to[v][i], v, dep + cost[v][i]);",
            "\t\t\t}",
            "\t\t};",
            "\t\tdfs(dfs, 0, -1, 0);",
            "\t\tint s = -1;",
            "\t\tll ma = -1;",
            "\t\trep(i, 0, n) {",
            "\t\t\tif(ma < dist[i]) {",
            "\t\t\t\ts = i;",
            "\t\t\t\tma = dist[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tdfs(dfs, s, -1, 0);",
            "\t\tint t = -1;",
            "\t\tma = -1;",
            "\t\trep(i, 0, n) {",
            "\t\t\tif(ma < dist[i]) {",
            "\t\t\t\tt = i;",
            "\t\t\t\tma = dist[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<int> vec;",
            "\t\tll cur = t;",
            "\t\twhile(cur != -1) {",
            "\t\t\tvec.push_back(cur);",
            "\t\t\tcur = par[cur];",
            "\t\t}",
            "\t\tpair<ll, vector<int>> res = {ma, vec};",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "LowestCommonAncestor": {
        "prefix": "LowestCommonAncestor",
        "body": [
            "template <typename T>  // T: type of cost",
            "struct LCA {",
            "\tll n, root, l;",
            "\tvector<vector<ll>> to;",
            "\tvector<vector<T>> co;",
            "\tvector<ll> dep;",
            "\tvector<T> costs;",
            "\tvector<vector<ll>> par;",
            "\tLCA(ll n)",
            "\t\t: n(n), to(n), co(n), dep(n), costs(n) {",
            "\t\tl = 0;",
            "\t\twhile((1 << l) < n) ++l;",
            "\t\tpar = vector<vector<ll>>(l, vector<ll>(n + 1, n));",
            "\t}",
            "\tvoid add_edge(ll a, ll b, T c = 0) {",
            "\t\tto[a].push_back(b);",
            "\t\tco[a].push_back(c);",
            "\t\tto[b].push_back(a);",
            "\t\tco[b].push_back(c);",
            "\t}",
            "\tvoid dfs(ll v, ll d, T c, ll p) {",
            "\t\tpar[0][v] = p;",
            "\t\tdep[v] = d;",
            "\t\tcosts[v] = c;",
            "\t\tfor(ll i = 0; i < (ll)to[v].size(); ++i) {",
            "\t\t\tll u = to[v][i];",
            "\t\t\tif(u == p) continue;",
            "\t\t\tdfs(u, d + 1, c + co[v][i], v);",
            "\t\t}",
            "\t}",
            "\tvoid init(ll _root = 0) {",
            "\t\troot = _root;",
            "\t\tdfs(root, 0, 0, n);",
            "\t\tfor(ll i = 0; i < l - 1; ++i) {",
            "\t\t\tfor(ll v = 0; v < n; ++v) {",
            "\t\t\t\tpar[i + 1][v] = par[i][par[i][v]];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// LCA",
            "\tll lca(ll a, ll b) {",
            "\t\tif(dep[a] > dep[b]) swap(a, b);",
            "\t\tll gap = dep[b] - dep[a];",
            "\t\tfor(ll i = l - 1; i >= 0; --i) {",
            "\t\t\tll len = 1 << i;",
            "\t\t\tif(gap >= len) {",
            "\t\t\t\tgap -= len;",
            "\t\t\t\tb = par[i][b];",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(a == b) return a;",
            "\t\tfor(ll i = l - 1; i >= 0; --i) {",
            "\t\t\tll na = par[i][a];",
            "\t\t\tll nb = par[i][b];",
            "\t\t\tif(na != nb) a = na, b = nb;",
            "\t\t}",
            "\t\treturn par[0][a];",
            "\t}",
            "\tll length(ll a, ll b) {",
            "\t\tll c = lca(a, b);",
            "\t\treturn dep[a] + dep[b] - dep[c] * 2;",
            "\t}",
            "\tT dist(ll a, ll b) {",
            "\t\tll c = lca(a, b);",
            "\t\treturn costs[a] + costs[b] - costs[c] * 2;",
            "\t}",
            "};"
        ]
    },
    "MaxFlow": {
        "prefix": "MaxFlow",
        "body": [
            "template <typename Cap>",
            "struct mf_graph {",
            "\tstruct _edge {",
            "\t\tint to, rev;",
            "\t\tCap cap;",
            "\t};",
            "\tstruct edge {",
            "\t\tint from, to;",
            "\t\tCap cap, flow;",
            "\t};",
            "\tint n;",
            "\tvector<pair<int, int>> pos;",
            "\tvector<vector<_edge>> g;",
            "\tmf_graph(int N)",
            "\t\t: n(N), g(N) {}",
            "\tint add_edge(int from, int to, Cap cap) {",
            "\t\tassert(0 <= from && from < n);",
            "\t\tassert(0 <= to && to < n);",
            "\t\tassert(0 <= cap);",
            "\t\tint m = int(pos.size());",
            "\t\tpos.push_back({from, int(g[from].size())});",
            "\t\tint from_id = int(g[from].size());",
            "\t\tint to_id = int(g[to].size());",
            "\t\tif(from == to) to_id++;",
            "\t\tg[from].push_back(_edge{to, to_id, cap});",
            "\t\tg[to].push_back(_edge{from, from_id, 0});",
            "\t\treturn m;",
            "\t}",
            "\tedge get_edge(int i) {",
            "\t\tint m = int(pos.size());",
            "\t\tassert(0 <= i && i < m);",
            "\t\tauto _e = g[pos[i].first][pos[i].second];",
            "\t\tauto _re = g[_e.to][_e.rev];",
            "\t\treturn edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};",
            "\t}",
            "\tvector<edge> edges() {",
            "\t\tint m = int(pos.size());",
            "\t\tvector<edge> result;",
            "\t\trep(i, 0, m) {",
            "\t\t\tresult.push_back(get_edge(i));",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "\tvoid change_edge(int i, Cap new_cap, Cap new_flow) {",
            "\t\tint m = int(pos.size());",
            "\t\tassert(0 <= i && i < m);",
            "\t\tassert(0 <= new_flow && new_flow <= new_cap);",
            "\t\tauto& _e = g[pos[i].first][pos[i].second];",
            "\t\tauto& _re = g[_e.to][_e.rev];",
            "\t\t_e.cap = new_cap - new_flow;",
            "\t\t_re.cap = new_flow;",
            "\t}",
            "\tCap flow(int s, int t) {",
            "\t\treturn flow(s, t, numeric_limits<Cap>::max());",
            "\t}",
            "\tCap flow(int s, int t, Cap flow_limit) {",
            "\t\tassert(0 <= s && s < n);",
            "\t\tassert(0 <= t && t < n);",
            "\t\tassert(s != t);",
            "\t\tvector<int> level(n), iter(n);",
            "\t\tqueue<int> que;",
            "\t\tauto bfs = [&]() -> void {",
            "\t\t\tfill(level.begin(), level.end(), -1);",
            "\t\t\tlevel[s] = 0;",
            "\t\t\tqueue<int>().swap(que);",
            "\t\t\tque.push(s);",
            "\t\t\twhile(!que.empty()) {",
            "\t\t\t\tint v = que.front();",
            "\t\t\t\tque.pop();",
            "\t\t\t\tfor(auto e : g[v]) {",
            "\t\t\t\t\tif(e.cap == 0 || level[e.to] >= 0) continue;",
            "\t\t\t\t\tlevel[e.to] = level[v] + 1;",
            "\t\t\t\t\tif(e.to == t) return;",
            "\t\t\t\t\tque.push(e.to);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t};",
            "\t\tauto dfs = [&](auto& dfs, int v, Cap up) -> Cap {",
            "\t\t\tif(v == s) return up;",
            "\t\t\tCap res = 0;",
            "\t\t\tint level_v = level[v];",
            "\t\t\tfor(int& i = iter[v]; i < int(g[v].size()); i++) {",
            "\t\t\t\t_edge& e = g[v][i];",
            "\t\t\t\tif(level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;",
            "\t\t\t\tCap d = dfs(dfs, e.to, min(up - res, g[e.to][e.rev].cap));",
            "\t\t\t\tif(d <= 0) continue;",
            "\t\t\t\tg[v][i].cap += d;",
            "\t\t\t\tg[e.to][e.rev].cap -= d;",
            "\t\t\t\tres += d;",
            "\t\t\t\tif(res == up) return res;",
            "\t\t\t}",
            "\t\t\tlevel[v] = n;",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tCap flow = 0;",
            "\t\twhile(flow < flow_limit) {",
            "\t\t\tbfs();",
            "\t\t\tif(level[t] == -1) break;",
            "\t\t\tfill(iter.begin(), iter.end(), 0);",
            "\t\t\tCap f = dfs(dfs, t, flow_limit - flow);",
            "\t\t\tif(!f) break;",
            "\t\t\tflow += f;",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\tvector<bool> min_cut(int s) {",
            "\t\tvector<bool> visited(n);",
            "\t\tqueue<int> que;",
            "\t\tque.push(s);",
            "\t\twhile(!que.empty()) {",
            "\t\t\tint p = que.front();",
            "\t\t\tque.pop();",
            "\t\t\tvisited[p] = true;",
            "\t\t\tfor(auto e : g[p]) {",
            "\t\t\t\tif(e.cap && !visited[e.to]) {",
            "\t\t\t\t\tvisited[e.to] = true;",
            "\t\t\t\t\tque.push(e.to);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn visited;",
            "\t}",
            "};"
        ]
    },
    "MinCostFlow": {
        "prefix": "MinCostFlow",
        "body": [
            "namespace internal {",
            "template <class E>",
            "struct csr {",
            "\tstd::vector<int> start;",
            "\tstd::vector<E> elist;",
            "\texplicit csr(int n, const std::vector<std::pair<int, E>>& edges)",
            "\t\t: start(n + 1), elist(edges.size()) {",
            "\t\tfor(auto e : edges) {",
            "\t\t\tstart[e.first + 1]++;",
            "\t\t}",
            "\t\tfor(int i = 1; i <= n; i++) {",
            "\t\t\tstart[i] += start[i - 1];",
            "\t\t}",
            "\t\tauto counter = start;",
            "\t\tfor(auto e : edges) {",
            "\t\t\telist[counter[e.first]++] = e.second;",
            "\t\t}",
            "\t}",
            "};",
            "template <class T>",
            "struct simple_queue {",
            "\tstd::vector<T> payload;",
            "\tint pos = 0;",
            "\tvoid reserve(int n) {",
            "\t\tpayload.reserve(n);",
            "\t}",
            "\tint size() const {",
            "\t\treturn int(payload.size()) - pos;",
            "\t}",
            "\tbool empty() const {",
            "\t\treturn pos == int(payload.size());",
            "\t}",
            "\tvoid push(const T& t) {",
            "\t\tpayload.push_back(t);",
            "\t}",
            "\tT& front() {",
            "\t\treturn payload[pos];",
            "\t}",
            "\tvoid clear() {",
            "\t\tpayload.clear();",
            "\t\tpos = 0;",
            "\t}",
            "\tvoid pop() {",
            "\t\tpos++;",
            "\t}",
            "};",
            "}  // namespace internal",
            "template <class Cap, class Cost>",
            "struct mcf_graph {",
            "   public:",
            "\tmcf_graph() {}",
            "\texplicit mcf_graph(int n)",
            "\t\t: _n(n) {}",
            "\tint add_edge(int from, int to, Cap cap, Cost cost) {",
            "\t\tassert(0 <= from && from < _n);",
            "\t\tassert(0 <= to && to < _n);",
            "\t\tassert(0 <= cap);",
            "\t\tassert(0 <= cost);",
            "\t\tint m = int(_edges.size());",
            "\t\t_edges.push_back({from, to, cap, 0, cost});",
            "\t\treturn m;",
            "\t}",
            "\tstruct edge {",
            "\t\tint from, to;",
            "\t\tCap cap, flow;",
            "\t\tCost cost;",
            "\t};",
            "\tedge get_edge(int i) {",
            "\t\tint m = int(_edges.size());",
            "\t\tassert(0 <= i && i < m);",
            "\t\treturn _edges[i];",
            "\t}",
            "\tstd::vector<edge> edges() {",
            "\t\treturn _edges;",
            "\t}",
            "\tstd::pair<Cap, Cost> flow(int s, int t) {",
            "\t\treturn flow(s, t, std::numeric_limits<Cap>::max());",
            "\t}",
            "\tstd::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {",
            "\t\treturn slope(s, t, flow_limit).back();",
            "\t}",
            "\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t) {",
            "\t\treturn slope(s, t, std::numeric_limits<Cap>::max());",
            "\t}",
            "\tstd::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {",
            "\t\tassert(0 <= s && s < _n);",
            "\t\tassert(0 <= t && t < _n);",
            "\t\tassert(s != t);",
            "\t\tint m = int(_edges.size());",
            "\t\tstd::vector<int> edge_idx(m);",
            "\t\tauto g = [&]() {",
            "\t\t\tstd::vector<int> degree(_n), redge_idx(m);",
            "\t\t\tstd::vector<std::pair<int, _edge>> elist;",
            "\t\t\telist.reserve(2 * m);",
            "\t\t\tfor(int i = 0; i < m; i++) {",
            "\t\t\t\tauto e = _edges[i];",
            "\t\t\t\tedge_idx[i] = degree[e.from]++;",
            "\t\t\t\tredge_idx[i] = degree[e.to]++;",
            "\t\t\t\telist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});",
            "\t\t\t\telist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});",
            "\t\t\t}",
            "\t\t\tauto _g = internal::csr<_edge>(_n, elist);",
            "\t\t\tfor(int i = 0; i < m; i++) {",
            "\t\t\t\tauto e = _edges[i];",
            "\t\t\t\tedge_idx[i] += _g.start[e.from];",
            "\t\t\t\tredge_idx[i] += _g.start[e.to];",
            "\t\t\t\t_g.elist[edge_idx[i]].rev = redge_idx[i];",
            "\t\t\t\t_g.elist[redge_idx[i]].rev = edge_idx[i];",
            "\t\t\t}",
            "\t\t\treturn _g;",
            "\t\t}();",
            "\t\tauto result = slope(g, s, t, flow_limit);",
            "\t\tfor(int i = 0; i < m; i++) {",
            "\t\t\tauto e = g.elist[edge_idx[i]];",
            "\t\t\t_edges[i].flow = _edges[i].cap - e.cap;",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "",
            "   private:",
            "\tint _n;",
            "\tstd::vector<edge> _edges;",
            "\tstruct _edge {",
            "\t\tint to, rev;",
            "\t\tCap cap;",
            "\t\tCost cost;",
            "\t};",
            "\tstd::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,",
            "\t\t\t\t\t\t\t\t\t\t\tint s,",
            "\t\t\t\t\t\t\t\t\t\t\tint t,",
            "\t\t\t\t\t\t\t\t\t\t\tCap flow_limit) {",
            "\t\tstd::vector<std::pair<Cost, Cost>> dual_dist(_n);",
            "\t\tstd::vector<int> prev_e(_n);",
            "\t\tstd::vector<bool> vis(_n);",
            "\t\tstruct Q {",
            "\t\t\tCost key;",
            "\t\t\tint to;",
            "\t\t\tbool operator<(Q r) const {",
            "\t\t\t\treturn key > r.key;",
            "\t\t\t}",
            "\t\t};",
            "\t\tstd::vector<int> que_min;",
            "\t\tstd::vector<Q> que;",
            "\t\tauto dual_ref = [&]() {",
            "\t\t\tfor(int i = 0; i < _n; i++) {",
            "\t\t\t\tdual_dist[i].second = std::numeric_limits<Cost>::max();",
            "\t\t\t}",
            "\t\t\tstd::fill(vis.begin(), vis.end(), false);",
            "\t\t\tque_min.clear();",
            "\t\t\tque.clear();",
            "\t\t\tsize_t heap_r = 0;",
            "\t\t\tdual_dist[s].second = 0;",
            "\t\t\tque_min.push_back(s);",
            "\t\t\twhile(!que_min.empty() || !que.empty()) {",
            "\t\t\t\tint v;",
            "\t\t\t\tif(!que_min.empty()) {",
            "\t\t\t\t\tv = que_min.back();",
            "\t\t\t\t\tque_min.pop_back();",
            "\t\t\t\t} else {",
            "\t\t\t\t\twhile(heap_r < que.size()) {",
            "\t\t\t\t\t\theap_r++;",
            "\t\t\t\t\t\tstd::push_heap(que.begin(), que.begin() + heap_r);",
            "\t\t\t\t\t}",
            "\t\t\t\t\tv = que.front().to;",
            "\t\t\t\t\tstd::pop_heap(que.begin(), que.end());",
            "\t\t\t\t\tque.pop_back();",
            "\t\t\t\t\theap_r--;",
            "\t\t\t\t}",
            "\t\t\t\tif(vis[v]) continue;",
            "\t\t\t\tvis[v] = true;",
            "\t\t\t\tif(v == t) break;",
            "\t\t\t\tCost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;",
            "\t\t\t\tfor(int i = g.start[v]; i < g.start[v + 1]; i++) {",
            "\t\t\t\t\tauto e = g.elist[i];",
            "\t\t\t\t\tif(!e.cap) continue;",
            "\t\t\t\t\tCost cost = e.cost - dual_dist[e.to].first + dual_v;",
            "\t\t\t\t\tif(dual_dist[e.to].second - dist_v > cost) {",
            "\t\t\t\t\t\tCost dist_to = dist_v + cost;",
            "\t\t\t\t\t\tdual_dist[e.to].second = dist_to;",
            "\t\t\t\t\t\tprev_e[e.to] = e.rev;",
            "\t\t\t\t\t\tif(dist_to == dist_v) {",
            "\t\t\t\t\t\t\tque_min.push_back(e.to);",
            "\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\tque.push_back(Q{dist_to, e.to});",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(!vis[t]) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tfor(int v = 0; v < _n; v++) {",
            "\t\t\t\tif(!vis[v]) continue;",
            "\t\t\t\tdual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;",
            "\t\t\t}",
            "\t\t\treturn true;",
            "\t\t};",
            "\t\tCap flow = 0;",
            "\t\tCost cost = 0, prev_cost_per_flow = -1;",
            "\t\tstd::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};",
            "\t\twhile(flow < flow_limit) {",
            "\t\t\tif(!dual_ref()) break;",
            "\t\t\tCap c = flow_limit - flow;",
            "\t\t\tfor(int v = t; v != s; v = g.elist[prev_e[v]].to) {",
            "\t\t\t\tc = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);",
            "\t\t\t}",
            "\t\t\tfor(int v = t; v != s; v = g.elist[prev_e[v]].to) {",
            "\t\t\t\tauto& e = g.elist[prev_e[v]];",
            "\t\t\t\te.cap += c;",
            "\t\t\t\tg.elist[e.rev].cap -= c;",
            "\t\t\t}",
            "\t\t\tCost d = -dual_dist[s].first;",
            "\t\t\tflow += c;",
            "\t\t\tcost += c * d;",
            "\t\t\tif(prev_cost_per_flow == d) {",
            "\t\t\t\tresult.pop_back();",
            "\t\t\t}",
            "\t\t\tresult.push_back({flow, cost});",
            "\t\t\tprev_cost_per_flow = d;",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "};"
        ]
    },
    // String
    "RollingHash": {
        "prefix": "RollingHash",
        "body": [
            "struct RandomNumberGenerator {",
            "\tmt19937_64 mt;",
            "\tRandomNumberGenerator()",
            "\t\t: mt(chrono::steady_clock::now().time_since_epoch().count()) {}",
            "\tll operator()(ll l, ll r) {",
            "\t\tuniform_int_distribution<ll> dist(l, r);",
            "\t\treturn dist(mt);",
            "\t}",
            "} rng;",
            "struct RollingHash {",
            "\tusing ull = unsigned long long;",
            "\tconst ull MASK30 = (1ull << 30) - 1;",
            "\tconst ull MASK31 = (1ull << 31) - 1;",
            "\tconst ull MOD = (1ull << 61) - 1;",
            "\tconst ull POSITIVIZER = MOD * ((1ull << 3) - 1);",
            "\tint len;",
            "\tll base;",
            "\tvector<ull> pow;",
            "\tvector<ull> hash;",
            "\tRollingHash(string s, ll BASE = rng(1e8, 1e9)) {",
            "\t\tlen = s.size();",
            "\t\tbase = BASE;",
            "\t\tpow.resize(len + 5);",
            "\t\tpow[0] = 1;",
            "\t\trep(i, 1, (int)pow.size()) {",
            "\t\t\tpow[i] = calc_mod(mul(pow[i - 1], base));",
            "\t\t}",
            "\t\thash.resize(len + 1);",
            "\t\trep(i, 0, (int)len) {",
            "\t\t\thash[i + 1] = calc_mod(mul(hash[i], base) + s[i]);",
            "\t\t}",
            "\t}",
            "\tull mul(ull x, ull y) {",
            "\t\tll xu = x >> 31;",
            "\t\tll xd = x & MASK31;",
            "\t\tll yu = y >> 31;",
            "\t\tll yd = y & MASK31;",
            "\t\tll middlebit = xd * yu + xu * yd;",
            "\t\treturn ((xu * yu) << 1) + xd * yd + ((middlebit & MASK30) << 31) + (middlebit >> 30);",
            "\t}",
            "\tll calc_mod(ull val) {",
            "\t\tval = (val & MOD) + (val >> 61);",
            "\t\tif(val > MOD) val -= MOD;",
            "\t\treturn val;",
            "\t}",
            "\tll get(int l, int r) {",
            "\t\tassert(0 <= l and l <= r and r <= len);",
            "\t\treturn calc_mod(hash[r] + POSITIVIZER - mul(hash[l], pow[r - l]));",
            "\t}",
            "\tll get_hash(string &t) {",
            "\t\tll res = 0;",
            "\t\trep(i, 0, (int)t.size()) {",
            "\t\t\tres = calc_mod(mul(res, base) + t[i]);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tint find(string &t, int lower = 0) {",
            "\t\tll ha = get_hash(t);",
            "\t\trep(i, lower, len - (int)t.size() + 1) {",
            "\t\t\tif(ha == get(i, i + (int)t.size())) return i;",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "\tint LCP(RollingHash &a, RollingHash &b, int al, int bl) {",
            "\t\tint ok = 0, ng = min(a.len - al, b.len - bl) + 1;",
            "\t\twhile(ok + 1 < ng) {",
            "\t\t\tint med = (ok + ng) / 2;",
            "\t\t\tif(a.get(al, med + al) == b.get(bl, med + bl)) {",
            "\t\t\t\tok = med;",
            "\t\t\t} else {",
            "\t\t\t\tng = med;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ok;",
            "\t}",
            "};"
        ]
    },
    "Z_Algorithm": {
        "prefix": "Z_Algorithm",
        "body": [
            "template <class T>",
            "vector<int> z_algorithm(const vector<T>& s) {",
            "\tint n = int(s.size());",
            "\tif(n == 0) return {};",
            "\tvector<int> z(n);",
            "\tz[0] = 0;",
            "\tfor(int i = 1, j = 0; i < n; i++) {",
            "\t\tint& k = z[i];",
            "\t\tk = (j + z[j] <= i) ? 0 : min(j + z[j] - i, z[i - j]);",
            "\t\twhile(i + k < n && s[k] == s[i + k]) k++;",
            "\t\tif(j + z[j] < i + z[i]) j = i;",
            "\t}",
            "\tz[0] = n;",
            "\treturn z;",
            "}",
            "vector<int> z_algorithm(const string& s) {",
            "\tint n = int(s.size());",
            "\tvector<int> s2(n);",
            "\tfor(int i = 0; i < n; i++) {",
            "\t\ts2[i] = s[i];",
            "\t}",
            "\treturn z_algorithm(s2);",
            "}"
        ]
    },
    // Math
    "PrimalityTest": {
        "prefix": "PrimalityTest",
        "body": [
            "bool is_prime(ll n) {",
            "\tif(n == 1) return false;",
            "\tfor(ll i = 2; i * i <= n; i++) {",
            "\t\tif(n % i == 0) return false;",
            "\t}",
            "\treturn true;",
            "}"
        ]
    },
    "PrimeFactorization": {
        "prefix": "PrimeFactorization",
        "body": [
            "map<ll, ll> prime_factor(ll n) {",
            "\tmap<ll, ll> res;",
            "\tfor(ll i = 2; i * i <= n; i++) {",
            "\t\twhile(n % i == 0) {",
            "\t\t\tres[i]++;",
            "\t\t\tn = n / i;",
            "\t\t}",
            "\t}",
            "\tif(n != 1) {",
            "\t\tres[n] = 1;",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "Divisor": {
        "prefix": "Divisor",
        "body": [
            "vector<ll> divisor(ll n) {",
            "\tvector<ll> res;",
            "\tfor(ll i = 1; i * i <= n; i++) {",
            "\t\tif(n % i == 0) {",
            "\t\t\tres.push_back(i);",
            "\t\t\tif(i != n / i) res.push_back(n / i);",
            "\t\t}",
            "\t}",
            "\tsort(res.begin(), res.end());",
            "\treturn res;",
            "}"
        ]
    },
    "EratosthenesSeive": {
        "prefix": "EratosthenesSeive",
        "body": [
            "vector<ll> prime;",
            "vector<bool> is_prime;",
            "void seive(ll n) {",
            "\tis_prime.resize(n + 1, true);",
            "\tis_prime[0] = is_prime[1] = false;",
            "\trep(i, 2, n + 1) {",
            "\t\tif(is_prime[i]) {",
            "\t\t\tprime.push_back(i);",
            "\t\t\tfor(ll j = 2 * i; j <= n; j += i) {",
            "\t\t\t\tis_prime[j] = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "Binomial": {
        "prefix": "Binomial",
        "body": [
            "struct Binomial {",
            "\tvector<mint> fac, ifac;",
            "\tBinomial(int n)",
            "\t\t: fac(n + 1), ifac(n + 1) {",
            "\t\tfac[0] = 1;",
            "\t\trep(i, 1, n + 1) fac[i] = fac[i - 1] * i;",
            "\t\tifac[n] = fac[n].inv();",
            "\t\trrep(i, n, 1) ifac[i - 1] = ifac[i] * i;",
            "\t}",
            "\tmint fact(int n) {",
            "\t\tif(n < 0) return 0;",
            "\t\treturn fac[n];",
            "\t}",
            "\tmint perm(int n, int r) {",
            "\t\tif(n < 0 or n < r or r < 0) return 0;",
            "\t\treturn fac[n] * ifac[n - r];",
            "\t}",
            "\tmint comb(int n, int r) {",
            "\t\tif(n < 0 or n < r or r < 0) return 0;",
            "\t\treturn fac[n] * ifac[n - r] * ifac[r];",
            "\t}",
            "\tmint homo(int n, int r) {",
            "\t\tif(n < 0 or r < 0) return 0;",
            "\t\tif(r == 0) return 1;",
            "\t\treturn comb(n + r - 1, r);",
            "\t}",
            "\tmint operator()(int n, int r) {",
            "\t\treturn comb(n, r);",
            "\t}",
            "} binom(1000005);"
        ]
    },
    "Lucas": {
        "prefix": "Lucas",
        "body": [
            "struct Lucas {",
            "\tint mod;",
            "\tvector<mint> fact, ifact;",
            "\tLucas(int p) {",
            "\t\tmod = p;",
            "\t\tfact.resize(p);",
            "\t\tifact.resize(p);",
            "\t\tfact[0] = 1;",
            "\t\trep(i, 1, p) fact[i] = fact[i - 1] * i;",
            "\t\tifact[p - 1] = fact[p - 1].inv();",
            "\t\trrep(i, p - 1, 1) ifact[i - 1] = ifact[i] * i;",
            "\t}",
            "\tmint operator()(int n, int k) {",
            "\t\tif(k < 0 or k > n) return 0;",
            "\t\tmint res = 1;",
            "\t\twhile(n > 0) {",
            "\t\t\tll n0 = n % mod, k0 = k % mod;",
            "\t\t\tif(n0 < k0) return 0;",
            "\t\t\tres *= fact[n0] * ifact[k0] * ifact[n0 - k0];",
            "\t\t\tn /= mod;",
            "\t\t\tk /= mod;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "Matrix": {
        "prefix": "Matrix",
        "body": [
            "template <typename T>",
            "struct Matrix {",
            "\tint h, w;",
            "\tvector<vector<T>> A;",
            "\tMatrix(int h, int w, T val = 0)",
            "\t\t: h(h), w(w), A(h, vector<T>(w, val)) {}",
            "\tconst vector<T>& operator[](int i) const {",
            "\t\treturn A[i];",
            "\t}",
            "\tvector<T>& operator[](int i) {",
            "\t\treturn A[i];",
            "\t}",
            "\tstatic Matrix I(int n) {",
            "\t\tMatrix mat(n, n);",
            "\t\trep(i, 0, n) mat[i][i] = 1;",
            "\t\treturn mat;",
            "\t}",
            "\tMatrix& operator+=(const Matrix& B) {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\trep(i, 0, h) {",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\t(*this)[i][j] += B[i][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix& operator-=(const Matrix& B) {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\trep(i, 0, h) {",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\t(*this)[i][j] -= B[i][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix& operator*=(const Matrix& B) {",
            "\t\tassert(w == B.h);",
            "\t\tvector<vector<T>> C(h, vector<T>(B.w, 0));",
            "\t\trep(i, 0, h) rep(k, 0, w) rep(j, 0, B.w) {",
            "\t\t\tC[i][j] += (*this)[i][k] * B[k][j];",
            "\t\t}",
            "\t\tA.swap(C);",
            "\t\treturn (*this);",
            "\t}",
            "\tMatrix pow(ll t) const {",
            "\t\tassert(h == w);",
            "\t\tif(!t) return Matrix::I(h);",
            "\t\tif(t == 1) return *this;",
            "\t\tMatrix B = pow(t >> 1);",
            "\t\tB *= B;",
            "\t\tif(t & 1) B *= (*this);",
            "\t\treturn B;",
            "\t}",
            "\tMatrix operator+(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) += B);",
            "\t}",
            "\tMatrix operator-(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) -= B);",
            "\t}",
            "\tMatrix operator*(const Matrix& B) const {",
            "\t\treturn (Matrix(*this) *= B);",
            "\t}",
            "\tbool operator==(const Matrix& B) const {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\trep(i, 0, h) {",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\tif(A[i][j] != B[i][j]) return false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tbool operator!=(const Matrix& B) const {",
            "\t\tassert(h == B.h and w == B.w);",
            "\t\trep(i, 0, h) {",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\tif(A[i][j] != B[i][j]) return true;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tT determinant() const {",
            "\t\tassert(h == w);",
            "\t\tMatrix B(*this);",
            "\t\tT res = 1;",
            "\t\trep(i, 0, h) {",
            "\t\t\tint idx = -1;",
            "\t\t\trep(j, i, w) {",
            "\t\t\t\tif(B[j][i] != 0) {",
            "\t\t\t\t\tidx = j;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(idx == -1) return 0;",
            "\t\t\tif(i != idx) {",
            "\t\t\t\tres *= T(-1);",
            "\t\t\t\tswap(B[i], B[idx]);",
            "\t\t\t}",
            "\t\t\tres *= B[i][i];",
            "\t\t\tT inv = T(1) / B[i][i];",
            "\t\t\trep(j, 0, w) {",
            "\t\t\t\tB[i][j] *= inv;",
            "\t\t\t}",
            "\t\t\trep(j, i + 1, h) {",
            "\t\t\t\tT a = B[j][i];",
            "\t\t\t\tif(a == 0) continue;",
            "\t\t\t\trep(k, i, w) {",
            "\t\t\t\t\tB[j][k] -= B[i][k] * a;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ]
    },
    "ConvolutionArbitary": {
        "prefix": "ConvolutionArbitary",
        "body": [
            "template <class mint, internal::is_static_modint_t<mint> * = nullptr>",
            "vector<mint> convolution_arbitary(const vector<mint> &a, const vector<mint> &b) {",
            "\tint n = int(a.size()), m = int(b.size());",
            "\tstatic constexpr ll MOD1 = 754974721;",
            "\tstatic constexpr ll MOD2 = 167772161;",
            "\tstatic constexpr ll MOD3 = 469762049;",
            "\tstatic constexpr ll M1_inv_M2 = internal::inv_gcd(MOD1, MOD2).second;",
            "\tstatic constexpr ll M12_inv_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;",
            "\tstatic constexpr ll M12_mod = (MOD1 * MOD2) % mint::mod();",
            "\tvector<ll> a_(n), b_(m);",
            "\tfor(int i = 0; i < n; i++) a_[i] = a[i].val();",
            "\tfor(int i = 0; i < m; i++) b_[i] = b[i].val();",
            "\tvector<ll> x = convolution<MOD1>(a_, b_);",
            "\tvector<ll> y = convolution<MOD2>(a_, b_);",
            "\tvector<ll> z = convolution<MOD3>(a_, b_);",
            "\tvector<mint> c(n + m - 1);",
            "\tfor(int i = 0; i < n + m - 1; i++) {",
            "\t\tll v1 = (y[i] - x[i]) * M1_inv_M2 % MOD2;",
            "\t\tif(v1 < 0) v1 += MOD2;",
            "\t\tll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_inv_M3 % MOD3;",
            "\t\tif(v2 < 0) v2 += MOD3;",
            "\t\tc[i] = x[i] + MOD1 * v1 + M12_mod * v2;",
            "\t}",
            "\treturn c;",
            "}"
        ]
    },
    "FormalPowerSeries": {
        "prefix": "FormalPowerSeries",
        "body": [
            "template <class T>",
            "struct FPS : vector<T> {",
            "\tusing vector<T>::vector;",
            "\tusing F = FPS;",
            "\tF &operator=(const vector<T> &g) {",
            "\t\tconst int n = g.size();",
            "\t\tconst int m = (*this).size();",
            "\t\tif(m < n) (*this).resize(n);",
            "\t\tfor(int i = 0; i < n; i++) (*this)[i] = g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-() {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= -1;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; i++) (*this)[i] += g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] += r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; i++) (*this)[i] -= g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] -= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const F &g) {",
            "\t\t(*this) = convolution((*this), g);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const T &r) {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this) = convolution((*this), g.inv());",
            "\t\t(*this).resize(n);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const T &r) {",
            "\t\tT inv_r = r.inv();",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= inv_r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator<<=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).insert((*this).begin(), d, 0);",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF &operator>>=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).erase((*this).begin(), (*this).begin() + min(n, d));",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF operator*(const T &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const T &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const T &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const T &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator*(const F &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const F &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const F &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const F &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator%(const F &g) const {",
            "\t\treturn F(*this) %= g;",
            "\t}",
            "\tF operator<<(const int d) const {",
            "\t\treturn F(*this) <<= d;",
            "\t}",
            "\tF operator>>(const int d) const {",
            "\t\treturn F(*this) >>= d;",
            "\t}",
            "\tF pre(int sz) const {",
            "\t\treturn F(begin(*this), begin(*this) + min((int)this->size(), sz));",
            "\t}",
            "\tF inv(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n > 0 && (*this)[0] != T(0));",
            "\t\tF g(1);",
            "\t\tg[0] = (*this)[0].inv();",
            "\t\twhile((int)g.size() < deg) {",
            "\t\t\tint m = g.size();",
            "\t\t\tF f(begin(*this), begin(*this) + min(n, 2 * m));",
            "\t\t\tF r(g);",
            "\t\t\tf.resize(2 * m);",
            "\t\t\tr.resize(2 * m);",
            "\t\t\tinternal::butterfly(f);",
            "\t\t\tinternal::butterfly(r);",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) f[i] *= r[i];",
            "\t\t\tinternal::butterfly_inv(f);",
            "\t\t\tf.erase(f.begin(), f.begin() + m);",
            "\t\t\tf.resize(2 * m);",
            "\t\t\tinternal::butterfly(f);",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) f[i] *= r[i];",
            "\t\t\tinternal::butterfly_inv(f);",
            "\t\t\tT in = T(2 * m).inv();",
            "\t\t\tin *= -in;",
            "\t\t\tfor(int i = 0; i < m; i++) f[i] *= in;",
            "\t\t\tg.insert(g.end(), f.begin(), f.begin() + m);",
            "\t\t}",
            "\t\treturn g.pre(deg);",
            "\t}",
            "\tT eval(const T &a) {",
            "\t\tT x = 1;",
            "\t\tT ret = 0;",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) {",
            "\t\t\tret += (*this)[i] * x;",
            "\t\t\tx *= a;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\tvoid onemul(const int d, const T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = n - d - 1; i >= 0; i--) {",
            "\t\t\t(*this)[i + d] += (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tvoid onediv(const int d, const T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = 0; i < n - d; i++) {",
            "\t\t\t(*this)[i + d] -= (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tF diff() const {",
            "\t\tconst int n = (*this).size();",
            "\t\tF ret(n);",
            "\t\tfor(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * i;",
            "\t\tret[n - 1] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF integral() const {",
            "\t\tconst int n = (*this).size(), mod = T::mod();",
            "\t\tvector<T> inv(n);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i < n; i++) inv[i] = T(mod) - inv[mod % i] * (mod / i);",
            "\t\tF ret(n);",
            "\t\tfor(int i = n - 2; i >= 0; i--) ret[i + 1] = (*this)[i] * inv[i + 1];",
            "\t\tret[0] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF log(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert((*this)[0] == T(1));",
            "\t\treturn ((*this).diff() * (*this).inv(deg)).pre(deg).integral();",
            "\t}",
            "\tF exp(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n == 0 || (*this)[0] == 0);",
            "\t\tF Inv;",
            "\t\tInv.reserve(deg);",
            "\t\tInv.push_back(T(0));",
            "\t\tInv.push_back(T(1));",
            "\t\tauto inplace_integral = [&](F &f) -> void {",
            "\t\t\tconst int n = (int)f.size();",
            "\t\t\tint mod = T::mod();",
            "\t\t\twhile((int)Inv.size() <= n) {",
            "\t\t\t\tint i = Inv.size();",
            "\t\t\t\tInv.push_back((-Inv[mod % i]) * (mod / i));",
            "\t\t\t}",
            "\t\t\tf.insert(begin(f), T(0));",
            "\t\t\tfor(int i = 1; i <= n; i++) f[i] *= Inv[i];",
            "\t\t};",
            "\t\tauto inplace_diff = [](F &f) -> void {",
            "\t\t\tif(f.empty()) return;",
            "\t\t\tf.erase(begin(f));",
            "\t\t\tT coeff = 1;",
            "\t\t\tfor(int i = 0; i < (int)f.size(); i++) {",
            "\t\t\t\tf[i] *= coeff;",
            "\t\t\t\tcoeff++;",
            "\t\t\t}",
            "\t\t};",
            "\t\tF b{1, 1 < (int)(*this).size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};",
            "\t\tfor(int m = 2; m <= deg; m <<= 1) {",
            "\t\t\tauto y = b;",
            "\t\t\ty.resize(2 * m);",
            "\t\t\tinternal::butterfly(y);",
            "\t\t\tz1 = z2;",
            "\t\t\tF z(m);",
            "\t\t\tfor(int i = 0; i < m; i++) z[i] = y[i] * z1[i];",
            "\t\t\tinternal::butterfly_inv(z);",
            "\t\t\tT si = T(m).inv();",
            "\t\t\tfor(int i = 0; i < m; i++) z[i] *= si;",
            "\t\t\tfill(begin(z), begin(z) + m / 2, T(0));",
            "\t\t\tinternal::butterfly(z);",
            "\t\t\tfor(int i = 0; i < m; i++) z[i] *= -z1[i];",
            "\t\t\tinternal::butterfly_inv(z);",
            "\t\t\tfor(int i = 0; i < m; i++) z[i] *= si;",
            "\t\t\tc.insert(end(c), begin(z) + m / 2, end(z));",
            "\t\t\tz2 = c;",
            "\t\t\tz2.resize(2 * m);",
            "\t\t\tinternal::butterfly(z2);",
            "\t\t\tF x(begin((*this)), begin((*this)) + min<int>((*this).size(), m));",
            "\t\t\tx.resize(m);",
            "\t\t\tinplace_diff(x);",
            "\t\t\tx.push_back(T(0));",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < m; i++) x[i] *= y[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tfor(int i = 0; i < m; i++) x[i] *= si;",
            "\t\t\tx -= b.diff();",
            "\t\t\tx.resize(2 * m);",
            "\t\t\tfor(int i = 0; i < m - 1; i++) x[m + i] = x[i], x[i] = T(0);",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) x[i] *= z2[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tT si2 = T(m << 1).inv();",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) x[i] *= si2;",
            "\t\t\tx.pop_back();",
            "\t\t\tinplace_integral(x);",
            "\t\t\tfor(int i = m; i < min<int>((*this).size(), 2 * m); i++) x[i] += (*this)[i];",
            "\t\t\tfill(begin(x), begin(x) + m, T(0));",
            "\t\t\tinternal::butterfly(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) x[i] *= y[i];",
            "\t\t\tinternal::butterfly_inv(x);",
            "\t\t\tfor(int i = 0; i < 2 * m; i++) x[i] *= si2;",
            "\t\t\tb.insert(end(b), begin(x) + m, end(x));",
            "\t\t}",
            "\t\treturn b.pre(deg);",
            "\t}",
            "\tF pow(ll k, int deg = -1) {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tif(k == 0) {",
            "\t\t\tF ret(deg);",
            "\t\t\tif(deg) ret[0] = 1;",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tif((*this)[i] != T(0)) {",
            "\t\t\t\tT rev = T(1) / (*this)[i];",
            "\t\t\t\tF ret = (((*this * rev) >> i).log(deg) * k).exp(deg);",
            "\t\t\t\tret *= (*this)[i].pow(k);",
            "\t\t\t\tret = (ret << (i * k)).pre(deg);",
            "\t\t\t\tif((int)ret.size() < deg) ret.resize(deg, T(0));",
            "\t\t\t\treturn ret;",
            "\t\t\t}",
            "\t\t\tif(__int128_t(i + 1) * k >= deg) return F(deg, T(0));",
            "\t\t}",
            "\t\treturn F(deg, T(0));",
            "\t}",
            "\tF shift(T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int mod = T::mod();",
            "\t\tvector<T> inv(n + 1);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i <= n; i++) inv[i] = mod - inv[mod % i] * (mod / i);",
            "\t\tT x = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\t(*this)[i] *= x;",
            "\t\t\tx *= (i + 1);",
            "\t\t}",
            "\t\tF g(n);",
            "\t\tT y = 1;",
            "\t\tT now = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tg[n - i - 1] = now * y;",
            "\t\t\tnow *= c;",
            "\t\t\ty *= inv[i + 1];",
            "\t\t}",
            "\t\tauto tmp = convolution(g, (*this));",
            "\t\tT z = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\t(*this)[i] = tmp[n + i - 1] * z;",
            "\t\t\tz *= inv[i + 1];",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "};"
        ]
    },
    "FormalPowerSeriesArbitary": {
        "prefix": "FormalPowerSeriesArbitary",
        "body": [
            "template <class mint, internal::is_static_modint_t<mint> * = nullptr>",
            "vector<mint> convolution_arbitary(const vector<mint> &a, const vector<mint> &b) {",
            "\tint n = int(a.size()), m = int(b.size());",
            "\tstatic constexpr ll MOD1 = 754974721;",
            "\tstatic constexpr ll MOD2 = 167772161;",
            "\tstatic constexpr ll MOD3 = 469762049;",
            "\tstatic constexpr ll M1_inv_M2 = internal::inv_gcd(MOD1, MOD2).second;",
            "\tstatic constexpr ll M12_inv_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;",
            "\tstatic constexpr ll M12_mod = (MOD1 * MOD2) % mint::mod();",
            "\tvector<ll> a_(n), b_(m);",
            "\tfor(int i = 0; i < n; i++) a_[i] = a[i].val();",
            "\tfor(int i = 0; i < m; i++) b_[i] = b[i].val();",
            "\tvector<ll> x = convolution<MOD1>(a_, b_);",
            "\tvector<ll> y = convolution<MOD2>(a_, b_);",
            "\tvector<ll> z = convolution<MOD3>(a_, b_);",
            "\tvector<mint> c(n + m - 1);",
            "\tfor(int i = 0; i < n + m - 1; i++) {",
            "\t\tll v1 = (y[i] - x[i]) * M1_inv_M2 % MOD2;",
            "\t\tif(v1 < 0) v1 += MOD2;",
            "\t\tll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_inv_M3 % MOD3;",
            "\t\tif(v2 < 0) v2 += MOD3;",
            "\t\tc[i] = x[i] + MOD1 * v1 + M12_mod * v2;",
            "\t}",
            "\treturn c;",
            "}",
            "template <class T>",
            "struct FPS : vector<T> {",
            "\tusing vector<T>::vector;",
            "\tusing F = FPS;",
            "\tF &operator=(const vector<T> &g) {",
            "\t\tconst int n = g.size();",
            "\t\tconst int m = (*this).size();",
            "\t\tif(m < n) (*this).resize(n);",
            "\t\tfor(int i = 0; i < n; i++) (*this)[i] = g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-() {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= -1;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; i++) (*this)[i] += g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator+=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] += r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int m = g.size();",
            "\t\tif(n < m) (*this).resize(m);",
            "\t\tfor(int i = 0; i < m; i++) (*this)[i] -= g[i];",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator-=(const T &r) {",
            "\t\tif((int)(*this).size() == 0) (*this).resize(1);",
            "\t\t(*this)[0] -= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const F &g) {",
            "\t\t(*this) = convolution_arbitary((*this), g);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator*=(const T &r) {",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const F &g) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this) = convolution_arbitary((*this), g.inv());",
            "\t\t(*this).resize(n);",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator/=(const T &r) {",
            "\t\tT inv_r = r.inv();",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) (*this)[i] *= inv_r;",
            "\t\treturn (*this);",
            "\t}",
            "\tF &operator<<=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).insert((*this).begin(), d, 0);",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF &operator>>=(const int d) {",
            "\t\tconst int n = (*this).size();",
            "\t\t(*this).erase((*this).begin(), (*this).begin() + min(n, d));",
            "\t\t(*this).resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tF operator*(const T &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const T &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const T &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const T &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator*(const F &g) const {",
            "\t\treturn F(*this) *= g;",
            "\t}",
            "\tF operator-(const F &g) const {",
            "\t\treturn F(*this) -= g;",
            "\t}",
            "\tF operator+(const F &g) const {",
            "\t\treturn F(*this) += g;",
            "\t}",
            "\tF operator/(const F &g) const {",
            "\t\treturn F(*this) /= g;",
            "\t}",
            "\tF operator%(const F &g) const {",
            "\t\treturn F(*this) %= g;",
            "\t}",
            "\tF operator<<(const int d) const {",
            "\t\treturn F(*this) <<= d;",
            "\t}",
            "\tF operator>>(const int d) const {",
            "\t\treturn F(*this) >>= d;",
            "\t}",
            "\tF pre(int sz) const {",
            "\t\treturn F(begin(*this), begin(*this) + min((int)this->size(), sz));",
            "\t}",
            "\tF inv(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n > 0 && (*this)[0] != T(0));",
            "\t\tF ret({T(1) / (*this)[0]});",
            "\t\tfor(int i = 1; i < deg; i <<= 1) {",
            "\t\t\tret = (ret + ret - ret * ret * (*this).pre(i << 1)).pre(i << 1);",
            "\t\t}",
            "\t\treturn ret.pre(deg);",
            "\t}",
            "\tT eval(const T &a) {",
            "\t\tT x = 1;",
            "\t\tT ret = 0;",
            "\t\tfor(int i = 0; i < (int)(*this).size(); i++) {",
            "\t\t\tret += (*this)[i] * x;",
            "\t\t\tx *= a;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\tvoid onemul(const int d, const T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = n - d - 1; i >= 0; i--) {",
            "\t\t\t(*this)[i + d] += (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tvoid onediv(const int d, const T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tfor(int i = 0; i < n - d; i++) {",
            "\t\t\t(*this)[i + d] -= (*this)[i] * c;",
            "\t\t}",
            "\t}",
            "\tF diff() const {",
            "\t\tconst int n = (*this).size();",
            "\t\tF ret(n);",
            "\t\tfor(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * i;",
            "\t\tret[n - 1] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF integral() const {",
            "\t\tconst int n = (*this).size(), mod = T::mod();",
            "\t\tvector<T> inv(n);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i < n; i++) inv[i] = T(mod) - inv[mod % i] * (mod / i);",
            "\t\tF ret(n);",
            "\t\tfor(int i = n - 2; i >= 0; i--) ret[i + 1] = (*this)[i] * inv[i + 1];",
            "\t\tret[0] = 0;",
            "\t\treturn ret;",
            "\t}",
            "\tF log(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert((*this)[0] == T(1));",
            "\t\treturn ((*this).diff() * (*this).inv(deg)).pre(deg).integral();",
            "\t}",
            "\tF exp(int deg = -1) const {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tassert(n == 0 or (*this)[0] == T(0));",
            "\t\tF ret({T(1)});",
            "\t\tfor(int i = 1; i < deg; i <<= 1) {",
            "\t\t\tret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);",
            "\t\t}",
            "\t\treturn ret.pre(deg);",
            "\t}",
            "\tF pow(ll k, int deg = -1) {",
            "\t\tconst int n = (*this).size();",
            "\t\tif(deg == -1) deg = n;",
            "\t\tif(k == 0) {",
            "\t\t\tF ret(deg);",
            "\t\t\tif(deg) ret[0] = 1;",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tif((*this)[i] != T(0)) {",
            "\t\t\t\tT rev = T(1) / (*this)[i];",
            "\t\t\t\tF ret = (((*this * rev) >> i).log(deg) * k).exp(deg);",
            "\t\t\t\tret *= (*this)[i].pow(k);",
            "\t\t\t\tret = (ret << (i * k)).pre(deg);",
            "\t\t\t\tif((int)ret.size() < deg) ret.resize(deg, T(0));",
            "\t\t\t\treturn ret;",
            "\t\t\t}",
            "\t\t\tif(__int128_t(i + 1) * k >= deg) return F(deg, T(0));",
            "\t\t}",
            "\t\treturn F(deg, T(0));",
            "\t}",
            "\tF shift(T c) {",
            "\t\tconst int n = (*this).size();",
            "\t\tconst int mod = T::mod();",
            "\t\tvector<T> inv(n + 1);",
            "\t\tinv[1] = 1;",
            "\t\tfor(int i = 2; i <= n; i++) inv[i] = mod - inv[mod % i] * (mod / i);",
            "\t\tT x = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\t(*this)[i] *= x;",
            "\t\t\tx *= (i + 1);",
            "\t\t}",
            "\t\tF g(n);",
            "\t\tT y = 1;",
            "\t\tT now = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tg[n - i - 1] = now * y;",
            "\t\t\tnow *= c;",
            "\t\t\ty *= inv[i + 1];",
            "\t\t}",
            "\t\tauto tmp = convolution_arbitary(g, (*this));",
            "\t\tT z = 1;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\t(*this)[i] = tmp[n + i - 1] * z;",
            "\t\t\tz *= inv[i + 1];",
            "\t\t}",
            "\t\treturn (*this);",
            "\t}",
            "};"
        ]
    },
    // Geometry
    "Vector": {
        "prefix": "Vector",
        "body": [
            "const long double pi = acos(-1);",
            "const long double eps = 1e-7;",
            "struct V {",
            "\tlong double x, y;",
            "\tV(long double x = 0, long double y = 0)",
            "\t\t: x(x), y(y) {}",
            "\tV& operator+=(const V& v) {",
            "\t\tx += v.x;",
            "\t\ty += v.y;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator+(const V& v) const {",
            "\t\treturn V(*this) += v;",
            "\t}",
            "\tV& operator-=(const V& v) {",
            "\t\tx -= v.x;",
            "\t\ty -= v.y;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator-(const V& v) const {",
            "\t\treturn V(*this) -= v;",
            "\t}",
            "\tV& operator*=(long double s) {",
            "\t\tx *= s;",
            "\t\ty *= s;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator*(long double s) const {",
            "\t\treturn V(*this) *= s;",
            "\t}",
            "\tV& operator/=(long double s) {",
            "\t\tx /= s;",
            "\t\ty /= s;",
            "\t\treturn *this;",
            "\t}",
            "\tV operator/(long double s) const {",
            "\t\treturn V(*this) /= s;",
            "\t}",
            "\tlong double dot(const V& v) const {",
            "\t\treturn x * v.x + y * v.y;",
            "\t}",
            "\tlong double cross(const V& v) const {",
            "\t\treturn x * v.y - v.x * y;",
            "\t}",
            "\tlong double norm2() const {",
            "\t\treturn x * x + y * y;",
            "\t}",
            "\tlong double norm() const {",
            "\t\treturn sqrt(x * x + y * y);",
            "\t}",
            "\tlong double arg() const {",
            "\t\treturn atan2(y, x);",
            "\t}",
            "\tV rotate() const {",
            "\t\treturn V(y, -x);",
            "\t}",
            "\tint ort() const {",
            "\t\tif(abs(x) < eps && abs(y) < eps) return 0;",
            "\t\tif(y > 0) return x > 0 ? 1 : 2;",
            "\t\telse return x > 0 ? 4 : 3;",
            "\t}",
            "\tbool operator<(const V& v) const {",
            "\t\tlong double theta = arg();",
            "\t\tlong double vtheta = v.arg();",
            "\t\treturn theta < vtheta;",
            "\t}",
            "\t// bool operator<(const V& v) const {",
            "\t//\t int o = ort(), vo = v.ort();",
            "\t//\t if(o != vo) return o < vo;",
            "\t//\t return cross(v) > 0;",
            "\t// }",
            "\t// bool operator<(const V& v) const {",
            "\t//\t if(x != v.x) return x < v.x;",
            "\t//\t return y < v.y;",
            "\t// }",
            "};"
        ]
    },
}